#!/bin/bash
# =============================================================================
# DIVE V3 - Comprehensive Configuration Generator
# =============================================================================
# Purpose: Generate ALL configuration files from federation-registry.json (SSOT)
# Usage: ./scripts/federation/generate-all-configs.sh [instance] [--dry-run]
#        If no instance specified, generates for all instances
#
# Generated Files:
#   - terraform/instances/{instance}.tfvars
#   - frontend/.env.{instance}
#   - cloudflared/config-{instance}.yml (only validates existing)
#
# =============================================================================

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
REGISTRY_FILE="$PROJECT_ROOT/config/federation-registry.json"
DRY_RUN=false
INSTANCE_FILTER=""

# Parse arguments
for arg in "$@"; do
    case "$arg" in
        --dry-run) DRY_RUN=true ;;
        --help|-h) 
            echo "Usage: $0 [instance] [--dry-run]"
            echo "  instance: usa, fra, gbr, deu (optional, generates all if not specified)"
            echo "  --dry-run: Show what would be generated without writing files"
            exit 0
            ;;
        *) INSTANCE_FILTER=$(echo "$arg" | tr '[:upper:]' '[:lower:]') ;;
    esac
done

# Logging
log_info() { echo -e "${BLUE}ℹ${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1"; }
log_section() { echo -e "\n${CYAN}━━━ $1 ━━━${NC}"; }

# Validate prerequisites
validate_prerequisites() {
    log_info "Validating prerequisites..."
    
    if [ ! -f "$REGISTRY_FILE" ]; then
        log_error "Registry file not found: $REGISTRY_FILE"
        exit 1
    fi
    
    if ! command -v jq &> /dev/null; then
        log_error "jq is required but not installed"
        exit 1
    fi
    
    if ! jq empty "$REGISTRY_FILE" 2>/dev/null; then
        log_error "Invalid JSON in registry file"
        exit 1
    fi
    
    log_success "Prerequisites validated"
}

# Generate Terraform .tfvars
generate_tfvars() {
    local instance="$1"
    local instance_upper=$(echo "$instance" | tr '[:lower:]' '[:upper:]')
    local output_file="$PROJECT_ROOT/terraform/instances/${instance}.tfvars"
    
    log_info "Generating Terraform .tfvars for $instance_upper..."
    
    # Extract data from registry
    local instance_name=$(jq -r ".instances.$instance.name" "$REGISTRY_FILE")
    local instance_type=$(jq -r ".instances.$instance.type" "$REGISTRY_FILE")
    local app_url=$(jq -r ".instances.$instance.urls.app" "$REGISTRY_FILE")
    local api_url=$(jq -r ".instances.$instance.urls.api" "$REGISTRY_FILE")
    local idp_url=$(jq -r ".instances.$instance.urls.idp" "$REGISTRY_FILE")
    local keycloak_port=$(jq -r ".instances.$instance.ports.keycloak" "$REGISTRY_FILE")
    local admin_username=$(jq -r ".instances.$instance.keycloak.adminUsername" "$REGISTRY_FILE")
    local admin_password=$(jq -r ".defaults.adminPassword" "$REGISTRY_FILE")
    local create_test_users=$(jq -r ".instances.$instance.testUsers.create" "$REGISTRY_FILE")
    
    # Determine keycloak_url
    local keycloak_url
    if [ "$instance_type" = "local" ]; then
        keycloak_url="https://localhost:$keycloak_port"
    else
        keycloak_url="$idp_url"
    fi
    
    # Generate content
    local content
    content=$(cat <<EOF
# ${instance_name} Instance Configuration
# =============================================================================
# ⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
# =============================================================================
# This file is automatically generated from config/federation-registry.json
# To make changes:
#   1. Edit config/federation-registry.json
#   2. Run: ./scripts/federation/generate-all-configs.sh
#   3. Commit the registry change (this file is regenerated)
#
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# Source: federation-registry.json v$(jq -r '.version' "$REGISTRY_FILE")
# =============================================================================

keycloak_url            = "$keycloak_url"
keycloak_admin_username = "$admin_username"
keycloak_admin_password = "$admin_password"
app_url                 = "$app_url"
api_url                 = "$api_url"
idp_url                 = "$idp_url"
create_test_users       = $create_test_users

# Federation partners - URLs must match actual deployment URLs
federation_partners = {
EOF
)
    
    # Add federation partners
    local partners=$(jq -r ".federation.matrix.$instance[]?" "$REGISTRY_FILE")
    for partner in $partners; do
        local partner_code=$(echo "$partner" | tr '[:lower:]' '[:upper:]')
        local partner_name=$(jq -r ".instances.$partner.name" "$REGISTRY_FILE")
        local partner_idp_url=$(jq -r ".instances.$partner.urls.idp" "$REGISTRY_FILE")
        local partner_enabled=$(jq -r ".instances.$partner.enabled" "$REGISTRY_FILE")
        
        content+=$(cat <<EOF

  $partner = {
    instance_code = "$partner_code"
    instance_name = "$partner_name"
    idp_url       = "$partner_idp_url"
    enabled       = $partner_enabled
  }
EOF
)
    done
    content+="\n}"
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would write to: $output_file"
        echo -e "$content" | head -20
        echo "..."
    else
        mkdir -p "$(dirname "$output_file")"
        echo -e "$content" > "$output_file"
        log_success "Generated: $output_file"
    fi
}

# Generate frontend .env file
generate_frontend_env() {
    local instance="$1"
    local instance_upper=$(echo "$instance" | tr '[:lower:]' '[:upper:]')
    local output_file="$PROJECT_ROOT/frontend/.env.${instance}"
    
    log_info "Generating frontend .env for $instance_upper..."
    
    # Extract data from registry
    local instance_name=$(jq -r ".instances.$instance.name" "$REGISTRY_FILE")
    local domain=$(jq -r ".instances.$instance.deployment.domain" "$REGISTRY_FILE")
    local app_url=$(jq -r ".instances.$instance.urls.app" "$REGISTRY_FILE")
    local api_url=$(jq -r ".instances.$instance.urls.api" "$REGISTRY_FILE")
    local idp_url=$(jq -r ".instances.$instance.urls.idp" "$REGISTRY_FILE")
    local frontend_port=$(jq -r ".instances.$instance.ports.frontend" "$REGISTRY_FILE")
    local backend_port=$(jq -r ".instances.$instance.ports.backend" "$REGISTRY_FILE")
    local keycloak_port=$(jq -r ".instances.$instance.ports.keycloak" "$REGISTRY_FILE")
    
    # Build federation partner IdP domains list
    local idp_domains=""
    local partners=$(jq -r ".federation.matrix.$instance[]?" "$REGISTRY_FILE")
    for partner in $partners; do
        local partner_idp=$(jq -r ".instances.$partner.urls.idp" "$REGISTRY_FILE")
        if [ -n "$idp_domains" ]; then
            idp_domains+=","
        fi
        idp_domains+="$partner_idp"
    done
    
    # Determine locale based on instance
    local locale="en-US"
    case "$instance" in
        fra) locale="fr-FR" ;;
        deu) locale="de-DE" ;;
        gbr) locale="en-GB" ;;
    esac
    
    local content
    content=$(cat <<EOF
# DIVE V3 Frontend Environment - ${instance_name}
# =============================================================================
# ⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
# =============================================================================
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# Source: federation-registry.json v$(jq -r '.version' "$REGISTRY_FILE")
# =============================================================================

# Instance identification
NEXT_PUBLIC_INSTANCE=${instance_upper}
NEXT_PUBLIC_INSTANCE_NAME="${instance_name}"
NEXT_PUBLIC_APP_NAME="DIVE V3 - ${instance_name}"
NEXT_PUBLIC_LOCALE=${locale}

# URLs - Public facing (through Cloudflare tunnel)
NEXT_PUBLIC_API_URL=${api_url}
NEXT_PUBLIC_BACKEND_URL=${api_url}
NEXT_PUBLIC_BASE_URL=${app_url}

# Keycloak Configuration
NEXT_PUBLIC_KEYCLOAK_URL=${idp_url}
NEXT_PUBLIC_KEYCLOAK_REALM=dive-v3-broker
NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=dive-v3-client-broker
KEYCLOAK_CLIENT_ID=dive-v3-client-broker
KEYCLOAK_REALM=dive-v3-broker
KEYCLOAK_ISSUER=${idp_url}/realms/dive-v3-broker

# Internal Keycloak URL (Docker network)
KEYCLOAK_URL=https://keycloak:8443

# NextAuth Configuration
NEXTAUTH_URL=${app_url}

# CSP Domains
NEXT_PUBLIC_EXTERNAL_DOMAINS=https://localhost:${frontend_port},https://localhost:${backend_port},https://localhost:${keycloak_port},${app_url},${api_url},${idp_url}
NEXT_PUBLIC_IDP_DOMAINS=${idp_domains}
NEXT_PUBLIC_ALLOW_EXTERNAL_ANALYTICS=true

# Security
NODE_TLS_REJECT_UNAUTHORIZED=0
AUTH_TRUST_HOST=true
EOF
)

    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would write to: $output_file"
        echo "$content" | head -30
        echo "..."
    else
        echo "$content" > "$output_file"
        log_success "Generated: $output_file"
    fi
}

# Validate cloudflared config
validate_cloudflared_config() {
    local instance="$1"
    local config_file="$PROJECT_ROOT/cloudflared/config-${instance}.yml"
    
    # USA uses config.yml
    if [ "$instance" = "usa" ]; then
        config_file="$PROJECT_ROOT/cloudflared/config.yml"
    fi
    
    log_info "Validating cloudflared config for $instance..."
    
    if [ ! -f "$config_file" ]; then
        log_warning "Cloudflared config not found: $config_file"
        return 1
    fi
    
    # Check tunnel ID matches registry
    local registry_tunnel_id=$(jq -r ".instances.$instance.cloudflare.tunnelId" "$REGISTRY_FILE")
    local config_tunnel_id=$(grep "^tunnel:" "$config_file" | awk '{print $2}')
    
    if [ "$registry_tunnel_id" != "$config_tunnel_id" ]; then
        log_error "Tunnel ID mismatch for $instance:"
        log_error "  Registry: $registry_tunnel_id"
        log_error "  Config:   $config_tunnel_id"
        return 1
    fi
    
    # Check credentials file exists
    local creds_file_name=$(jq -r ".instances.$instance.cloudflare.credentialsFile" "$REGISTRY_FILE")
    local creds_file="$PROJECT_ROOT/$creds_file_name"
    
    if [ ! -f "$creds_file" ]; then
        log_warning "Credentials file not found: $creds_file"
        log_warning "Create it from Cloudflare dashboard before deployment"
    else
        log_success "Credentials file exists: $creds_file"
    fi
    
    log_success "Cloudflared config validated for $instance"
    return 0
}

# Generate summary report
generate_summary() {
    log_section "Configuration Generation Summary"
    
    local instances
    if [ -n "$INSTANCE_FILTER" ]; then
        instances="$INSTANCE_FILTER"
    else
        instances=$(jq -r '.instances | keys[]' "$REGISTRY_FILE")
    fi
    
    echo ""
    echo "Registry Version: $(jq -r '.version' "$REGISTRY_FILE")"
    echo "Dry Run: $DRY_RUN"
    echo ""
    echo "Generated configurations for:"
    for instance in $instances; do
        local instance_upper=$(echo "$instance" | tr '[:lower:]' '[:upper:]')
        local instance_type=$(jq -r ".instances.$instance.type" "$REGISTRY_FILE")
        echo "  - $instance_upper ($instance_type)"
    done
    echo ""
    
    if [ "$DRY_RUN" = false ]; then
        echo "Files generated:"
        echo "  - terraform/instances/*.tfvars"
        echo "  - frontend/.env.*"
        echo ""
        echo "Next steps:"
        echo "  1. Review generated files"
        echo "  2. Run: ./scripts/deploy-federation.sh"
        echo "  3. After Terraform: ./scripts/sync-federation-secrets.sh"
    fi
}

# Main execution
main() {
    echo ""
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║       DIVE V3 Configuration Generator                        ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo ""
    
    validate_prerequisites
    
    local instances
    if [ -n "$INSTANCE_FILTER" ]; then
        if ! jq -e ".instances.$INSTANCE_FILTER" "$REGISTRY_FILE" > /dev/null 2>&1; then
            log_error "Instance '$INSTANCE_FILTER' not found in registry"
            exit 1
        fi
        instances="$INSTANCE_FILTER"
    else
        instances=$(jq -r '.instances | keys[]' "$REGISTRY_FILE")
    fi
    
    for instance in $instances; do
        log_section "Processing $instance"
        generate_tfvars "$instance"
        generate_frontend_env "$instance"
        validate_cloudflared_config "$instance" || true
    done
    
    generate_summary
    
    echo ""
    if [ "$DRY_RUN" = false ]; then
        log_success "Configuration generation complete!"
    else
        log_info "Dry run complete - no files were written"
    fi
}

main "$@"

