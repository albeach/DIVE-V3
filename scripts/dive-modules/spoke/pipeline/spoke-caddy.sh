#!/usr/bin/env bash
# =============================================================================
# DIVE V3 — Spoke Caddy Integration
# =============================================================================
# Generates Caddy reverse proxy configuration for spoke instances when
# deployed with DIVE_DOMAIN_SUFFIX (EC2 with Caddy + Let's Encrypt).
#
# Functions:
#   spoke_caddy_setup(CODE)          - Full setup: DNS + snippet + reload
#   spoke_caddy_generate_snippet(CODE) - Write Caddyfile snippet for spoke
#   spoke_caddy_create_dns(CODE)     - Create Cloudflare A records
#   spoke_caddy_reload()             - Reload Caddy to pick up changes
# =============================================================================

[ -n "${SPOKE_CADDY_LOADED:-}" ] && return 0
export SPOKE_CADDY_LOADED=1

CADDY_SPOKES_DIR="${DIVE_ROOT}/docker/caddy/spokes"

##
# Full Caddy setup for a spoke: DNS records + Caddyfile snippet + reload
#
# Arguments:
#   $1 - Instance code (e.g., GBR)
##
spoke_caddy_setup() {
    local code="$1"

    if [ -z "${DIVE_DOMAIN_SUFFIX:-}" ] && [ -z "${SPOKE_CUSTOM_DOMAIN:-}" ]; then
        log_verbose "No DIVE_DOMAIN_SUFFIX or SPOKE_CUSTOM_DOMAIN set — skipping Caddy spoke setup"
        return 0
    fi

    log_info "Setting up Caddy reverse proxy for spoke ${code}..."

    spoke_caddy_create_dns "$code"

    if [ "${DEPLOYMENT_MODE:-local}" = "remote" ]; then
        # Remote mode: generate spoke-local Caddyfile from template
        spoke_caddy_generate_local "$code"
    else
        # Local mode: add snippet to Hub Caddy (same Docker host)
        spoke_caddy_generate_snippet "$code"
        spoke_caddy_reload
    fi

    log_success "Caddy configured for spoke ${code}"
}

##
# Generate a Caddyfile snippet for a spoke instance
#
# Creates docker/caddy/spokes/{code_lower}.caddy with domain blocks
# for app, api, and idp subdomains pointing to spoke containers.
#
# Arguments:
#   $1 - Instance code (e.g., GBR)
##
spoke_caddy_generate_snippet() {
    local code="$1"
    local code_lower
    code_lower="$(echo "$code" | tr '[:upper:]' '[:lower:]')"

    local _env_prefix _base_domain
    _env_prefix="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f1)"
    _base_domain="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f2-)"

    local domain_app="${_env_prefix}-${code_lower}-app.${_base_domain}"
    local domain_api="${_env_prefix}-${code_lower}-api.${_base_domain}"
    local domain_idp="${_env_prefix}-${code_lower}-idp.${_base_domain}"

    # Spoke container names (on dive-shared network)
    local container_frontend="dive-spoke-${code_lower}-frontend"
    local container_backend="dive-spoke-${code_lower}-backend"
    local container_keycloak="dive-spoke-${code_lower}-keycloak"

    mkdir -p "$CADDY_SPOKES_DIR"

    local snippet_file="${CADDY_SPOKES_DIR}/${code_lower}.caddy"

    cat > "$snippet_file" << CADDY_EOF
# =============================================================================
# Spoke ${code} — Auto-generated by ./dive spoke deploy ${code}
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# =============================================================================

# Frontend
${domain_app} {
	reverse_proxy http://${container_frontend}:3000 {
		# Standalone Next.js serves HTTP internally; Caddy terminates TLS
	}

	header {
		Strict-Transport-Security "max-age=31536000; includeSubDomains"
		X-Frame-Options "SAMEORIGIN"
		X-Content-Type-Options "nosniff"
		X-XSS-Protection "1; mode=block"
		Referrer-Policy "no-referrer-when-downgrade"
	}
}

# Backend API
${domain_api} {
	reverse_proxy https://${container_backend}:4000 {
		transport http {
			tls_insecure_skip_verify
		}
	}

	header {
		Strict-Transport-Security "max-age=31536000; includeSubDomains"
		X-Content-Type-Options "nosniff"
	}
}

# Keycloak IdP
${domain_idp} {
	reverse_proxy https://${container_keycloak}:8443 {
		transport http {
			tls_insecure_skip_verify
		}
		flush_interval -1
	}

	header {
		Strict-Transport-Security "max-age=31536000; includeSubDomains"
		X-Content-Type-Options "nosniff"
	}
}
CADDY_EOF

    log_success "Caddy snippet: ${snippet_file}"
    log_info "  ${domain_app} → ${container_frontend}:3000"
    log_info "  ${domain_api} → ${container_backend}:4000"
    log_info "  ${domain_idp} → ${container_keycloak}:8443"
}

##
# Create Cloudflare DNS A records for spoke domains
#
# Uses CLOUDFLARE_API_TOKEN and the dive25.com zone to create/update
# A records pointing to the EC2 instance's public IP.
#
# Arguments:
#   $1 - Instance code (e.g., GBR)
##
spoke_caddy_create_dns() {
    local code="$1"
    local code_lower
    code_lower="$(echo "$code" | tr '[:upper:]' '[:lower:]')"

    # Custom domains: operator manages their own DNS
    if [ -n "${SPOKE_CUSTOM_DOMAIN:-}" ]; then
        log_info "Custom domain — DNS must be managed by the domain operator"
        log_info "Create A records for: app.${SPOKE_CUSTOM_DOMAIN}, api.${SPOKE_CUSTOM_DOMAIN}, idp.${SPOKE_CUSTOM_DOMAIN}"
        return 0
    fi

    local _env_prefix _base_domain
    _env_prefix="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f1)"
    _base_domain="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f2-)"

    # Get public IP: for remote spokes, use the SPOKE's own IP (not the hub)
    local public_ip=""
    if [ "${DEPLOYMENT_MODE:-local}" = "remote" ]; then
        # Remote mode: use this instance's own public IP (from EC2 metadata)
        public_ip="${INSTANCE_PUBLIC_IP:-}"
    fi
    if [ -z "$public_ip" ]; then
        public_ip="${HUB_EXTERNAL_ADDRESS:-}"
    fi
    if [ -z "$public_ip" ]; then
        # Try EC2 metadata
        local imds_token
        imds_token=$(curl -s --max-time 2 -X PUT "http://169.254.169.254/latest/api/token" \
            -H "X-aws-ec2-metadata-token-ttl-seconds: 60" 2>/dev/null || echo "")
        if [ -n "$imds_token" ]; then
            public_ip=$(curl -s --max-time 2 -H "X-aws-ec2-metadata-token: ${imds_token}" \
                "http://169.254.169.254/latest/meta-data/public-ipv4" 2>/dev/null || echo "")
        fi
    fi

    if [ -z "$public_ip" ]; then
        log_warn "Cannot determine public IP — DNS records must be created manually"
        return 0
    fi

    # Source shared DNS helpers (dns.sh provides _dns_get_token, _dns_create_or_update)
    local _dns_module="${DIVE_ROOT}/scripts/dive-modules/configuration/dns.sh"
    if [ -f "$_dns_module" ]; then
        source "$_dns_module"
    fi

    # Resolve Cloudflare token via shared helper or inline fallback
    local cf_token=""
    if type _dns_get_token &>/dev/null; then
        cf_token=$(_dns_get_token 2>/dev/null) || true
    else
        cf_token="${CLOUDFLARE_API_TOKEN:-}"
        if [ -z "$cf_token" ] && [ -f "${DIVE_ROOT}/.env.hub" ]; then
            cf_token=$(grep "^CLOUDFLARE_API_TOKEN=" "${DIVE_ROOT}/.env.hub" 2>/dev/null | cut -d= -f2-)
        fi
    fi

    if [ -z "$cf_token" ]; then
        log_warn "No CLOUDFLARE_API_TOKEN — DNS records must be created manually"
        log_info "Create A records for: ${_env_prefix}-${code_lower}-{app,api,idp}.${_base_domain} → ${public_ip}"
        return 0
    fi

    local zone_id="${CLOUDFLARE_ZONE_ID:-53200276d1d66a21b6c881ecd1c05414}"

    local subdomains=("${_env_prefix}-${code_lower}-app" "${_env_prefix}-${code_lower}-api" "${_env_prefix}-${code_lower}-idp")

    for sub in "${subdomains[@]}"; do
        local fqdn="${sub}.${_base_domain}"

        if type _dns_create_or_update &>/dev/null; then
            # Use shared DNS helper from dns.sh
            _dns_create_or_update "$cf_token" "$zone_id" "$fqdn" "$public_ip" || {
                log_warn "Failed to set DNS for ${fqdn}"
                continue
            }
            log_verbose "DNS set: ${fqdn} → ${public_ip}"
        else
            # Inline fallback if dns.sh not available
            local existing
            existing=$(curl -s --max-time 10 \
                -H "Authorization: Bearer ${cf_token}" \
                -H "Content-Type: application/json" \
                "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records?name=${fqdn}&type=A" 2>/dev/null)

            local record_id
            record_id=$(echo "$existing" | jq -r '.result[0].id // empty' 2>/dev/null)

            if [ -n "$record_id" ]; then
                curl -s --max-time 10 -X PUT \
                    -H "Authorization: Bearer ${cf_token}" \
                    -H "Content-Type: application/json" \
                    "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records/${record_id}" \
                    -d "{\"type\":\"A\",\"name\":\"${fqdn}\",\"content\":\"${public_ip}\",\"ttl\":300,\"proxied\":false}" \
                    >/dev/null 2>&1
                log_verbose "DNS updated: ${fqdn} → ${public_ip}"
            else
                curl -s --max-time 10 -X POST \
                    -H "Authorization: Bearer ${cf_token}" \
                    -H "Content-Type: application/json" \
                    "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records" \
                    -d "{\"type\":\"A\",\"name\":\"${fqdn}\",\"content\":\"${public_ip}\",\"ttl\":300,\"proxied\":false}" \
                    >/dev/null 2>&1
                log_verbose "DNS created: ${fqdn} → ${public_ip}"
            fi
        fi
    done

    log_success "Cloudflare DNS records set for ${code}: ${_env_prefix}-${code_lower}-{app,api,idp}.${_base_domain} → ${public_ip}"
}

##
# Reload Caddy to pick up new spoke configuration
##
spoke_caddy_reload() {
    local caddy_container="${COMPOSE_PROJECT_NAME:-dive-hub}-caddy"

    if ! docker ps --format '{{.Names}}' 2>/dev/null | grep -q "$caddy_container"; then
        log_warn "Caddy container '${caddy_container}' not running — skipping reload"
        return 0
    fi

    log_info "Reloading Caddy to pick up spoke configuration..."
    if docker exec "$caddy_container" caddy reload --config /etc/caddy/Caddyfile 2>/dev/null; then
        log_success "Caddy reloaded successfully"
    else
        log_warn "Caddy reload failed — may need manual restart: docker restart ${caddy_container}"
    fi
}

##
# Generate spoke-local Caddy configuration for remote deployments
#
# Creates a Caddyfile in instances/{code}/caddy/ from the spoke Caddy template.
# Also adds CADDY_DOMAIN_* vars to the spoke .env for docker-compose.
# The spoke's own Caddy container (profile: caddy) handles TLS termination.
#
# Arguments:
#   $1 - Instance code (e.g., GBR)
##
spoke_caddy_generate_local() {
    local code="$1"
    local code_lower
    code_lower="$(echo "$code" | tr '[:upper:]' '[:lower:]')"
    local code_upper
    code_upper="$(echo "$code" | tr '[:lower:]' '[:upper:]')"

    local spoke_dir="${DIVE_ROOT}/instances/${code_lower}"
    local caddy_dir="${spoke_dir}/caddy"
    local template_file="${DIVE_ROOT}/templates/spoke/caddy/Caddyfile.template"

    if [ ! -f "$template_file" ]; then
        log_warn "Spoke Caddy template not found: ${template_file}"
        return 0
    fi

    mkdir -p "$caddy_dir"

    # Render Caddyfile template
    local content
    content=$(cat "$template_file")
    content="${content//\{\{INSTANCE_CODE_UPPER\}\}/${code_upper}}"
    content="${content//\{\{INSTANCE_CODE_LOWER\}\}/${code_lower}}"
    echo "$content" > "${caddy_dir}/Caddyfile"

    # Derive domain names for Caddy env vars
    local domain_app domain_api domain_idp

    if [ -n "${SPOKE_CUSTOM_DOMAIN:-}" ]; then
        # Custom domain: app.<domain>, api.<domain>, idp.<domain>
        domain_app="app.${SPOKE_CUSTOM_DOMAIN}"
        domain_api="api.${SPOKE_CUSTOM_DOMAIN}"
        domain_idp="idp.${SPOKE_CUSTOM_DOMAIN}"
    else
        local _env_prefix _base_domain
        _env_prefix="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f1)"
        _base_domain="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f2-)"
        domain_app="${_env_prefix}-${code_lower}-app.${_base_domain}"
        domain_api="${_env_prefix}-${code_lower}-api.${_base_domain}"
        domain_idp="${_env_prefix}-${code_lower}-idp.${_base_domain}"
    fi

    local env_file="${spoke_dir}/.env"
    if [ -f "$env_file" ]; then
        # Remove old Caddy vars if present, then add fresh
        sed -i.bak '/^CADDY_DOMAIN_/d; /^SPOKE_CADDY_ENABLED/d; /^CLOUDFLARE_API_TOKEN/d' "$env_file"
        rm -f "${env_file}.bak"

        cat >> "$env_file" << CADDY_ENV

# Caddy reverse proxy domains (remote mode)
SPOKE_CADDY_ENABLED=true
CADDY_DOMAIN_APP=${domain_app}
CADDY_DOMAIN_API=${domain_api}
CADDY_DOMAIN_IDP=${domain_idp}
CLOUDFLARE_API_TOKEN=${CLOUDFLARE_API_TOKEN:-}
CADDY_ENV
    fi

    log_success "Spoke-local Caddy configured: ${caddy_dir}/Caddyfile"
    log_info "  ${domain_app} → frontend-${code_lower}:3000"
    log_info "  ${domain_api} → backend-${code_lower}:4000"
    log_info "  ${domain_idp} → keycloak-${code_lower}:8443"
}

export -f spoke_caddy_setup
export -f spoke_caddy_generate_snippet
export -f spoke_caddy_generate_local
export -f spoke_caddy_create_dns
export -f spoke_caddy_reload
