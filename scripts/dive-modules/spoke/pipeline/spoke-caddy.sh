#!/usr/bin/env bash
# =============================================================================
# DIVE V3 — Spoke Caddy Integration
# =============================================================================
# Generates Caddy reverse proxy configuration for spoke instances when
# deployed with DIVE_DOMAIN_SUFFIX (EC2 with Caddy + Let's Encrypt).
#
# Functions:
#   spoke_caddy_setup(CODE)          - Full setup: DNS + snippet + reload
#   spoke_caddy_generate_snippet(CODE) - Write Caddyfile snippet for spoke
#   spoke_caddy_create_dns(CODE)     - Create Cloudflare A records
#   spoke_caddy_reload()             - Reload Caddy to pick up changes
# =============================================================================

[ -n "${SPOKE_CADDY_LOADED:-}" ] && return 0
export SPOKE_CADDY_LOADED=1

CADDY_SPOKES_DIR="${DIVE_ROOT}/docker/caddy/spokes"

##
# Full Caddy setup for a spoke: DNS records + Caddyfile snippet + reload
#
# Arguments:
#   $1 - Instance code (e.g., GBR)
##
spoke_caddy_setup() {
    local code="$1"

    if [ -z "${DIVE_DOMAIN_SUFFIX:-}" ]; then
        log_verbose "No DIVE_DOMAIN_SUFFIX set — skipping Caddy spoke setup"
        return 0
    fi

    log_info "Setting up Caddy reverse proxy for spoke ${code}..."

    spoke_caddy_create_dns "$code"
    spoke_caddy_generate_snippet "$code"
    spoke_caddy_reload

    log_success "Caddy configured for spoke ${code}"
}

##
# Generate a Caddyfile snippet for a spoke instance
#
# Creates docker/caddy/spokes/{code_lower}.caddy with domain blocks
# for app, api, and idp subdomains pointing to spoke containers.
#
# Arguments:
#   $1 - Instance code (e.g., GBR)
##
spoke_caddy_generate_snippet() {
    local code="$1"
    local code_lower
    code_lower="$(echo "$code" | tr '[:upper:]' '[:lower:]')"

    local _env_prefix _base_domain
    _env_prefix="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f1)"
    _base_domain="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f2-)"

    local domain_app="${_env_prefix}-${code_lower}-app.${_base_domain}"
    local domain_api="${_env_prefix}-${code_lower}-api.${_base_domain}"
    local domain_idp="${_env_prefix}-${code_lower}-idp.${_base_domain}"

    # Spoke container names (on dive-shared network)
    local container_frontend="dive-spoke-${code_lower}-frontend"
    local container_backend="dive-spoke-${code_lower}-backend"
    local container_keycloak="dive-spoke-${code_lower}-keycloak"

    mkdir -p "$CADDY_SPOKES_DIR"

    local snippet_file="${CADDY_SPOKES_DIR}/${code_lower}.caddy"

    cat > "$snippet_file" << CADDY_EOF
# =============================================================================
# Spoke ${code} — Auto-generated by ./dive spoke deploy ${code}
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# =============================================================================

# Frontend
${domain_app} {
	reverse_proxy http://${container_frontend}:3000 {
		# Standalone Next.js serves HTTP internally; Caddy terminates TLS
	}

	header {
		Strict-Transport-Security "max-age=31536000; includeSubDomains"
		X-Frame-Options "SAMEORIGIN"
		X-Content-Type-Options "nosniff"
		X-XSS-Protection "1; mode=block"
		Referrer-Policy "no-referrer-when-downgrade"
	}
}

# Backend API
${domain_api} {
	reverse_proxy https://${container_backend}:4000 {
		transport http {
			tls_insecure_skip_verify
		}
	}

	header {
		Strict-Transport-Security "max-age=31536000; includeSubDomains"
		X-Content-Type-Options "nosniff"
	}
}

# Keycloak IdP
${domain_idp} {
	reverse_proxy https://${container_keycloak}:8443 {
		transport http {
			tls_insecure_skip_verify
		}
		flush_interval -1
	}

	header {
		Strict-Transport-Security "max-age=31536000; includeSubDomains"
		X-Content-Type-Options "nosniff"
	}
}
CADDY_EOF

    log_success "Caddy snippet: ${snippet_file}"
    log_info "  ${domain_app} → ${container_frontend}:3000"
    log_info "  ${domain_api} → ${container_backend}:4000"
    log_info "  ${domain_idp} → ${container_keycloak}:8443"
}

##
# Create Cloudflare DNS A records for spoke domains
#
# Uses CLOUDFLARE_API_TOKEN and the dive25.com zone to create/update
# A records pointing to the EC2 instance's public IP.
#
# Arguments:
#   $1 - Instance code (e.g., GBR)
##
spoke_caddy_create_dns() {
    local code="$1"
    local code_lower
    code_lower="$(echo "$code" | tr '[:upper:]' '[:lower:]')"

    local _env_prefix _base_domain
    _env_prefix="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f1)"
    _base_domain="$(echo "${DIVE_DOMAIN_SUFFIX}" | cut -d. -f2-)"

    # Get public IP
    local public_ip="${HUB_EXTERNAL_ADDRESS:-}"
    if [ -z "$public_ip" ]; then
        # Try EC2 metadata
        local imds_token
        imds_token=$(curl -s --max-time 2 -X PUT "http://169.254.169.254/latest/api/token" \
            -H "X-aws-ec2-metadata-token-ttl-seconds: 60" 2>/dev/null || echo "")
        if [ -n "$imds_token" ]; then
            public_ip=$(curl -s --max-time 2 -H "X-aws-ec2-metadata-token: ${imds_token}" \
                "http://169.254.169.254/latest/meta-data/public-ipv4" 2>/dev/null || echo "")
        fi
    fi

    if [ -z "$public_ip" ]; then
        log_warn "Cannot determine public IP — DNS records must be created manually"
        return 0
    fi

    local cf_token="${CLOUDFLARE_API_TOKEN:-}"
    if [ -z "$cf_token" ]; then
        # Try to read from .env.hub
        if [ -f "${DIVE_ROOT}/.env.hub" ]; then
            cf_token=$(grep "^CLOUDFLARE_API_TOKEN=" "${DIVE_ROOT}/.env.hub" 2>/dev/null | cut -d= -f2-)
        fi
    fi

    if [ -z "$cf_token" ]; then
        log_warn "No CLOUDFLARE_API_TOKEN — DNS records must be created manually"
        log_info "Create A records for: ${_env_prefix}-${code_lower}-{app,api,idp}.${_base_domain} → ${public_ip}"
        return 0
    fi

    # Cloudflare zone ID for dive25.com
    local zone_id="53200276d1d66a21b6c881ecd1c05414"

    local subdomains=("${_env_prefix}-${code_lower}-app" "${_env_prefix}-${code_lower}-api" "${_env_prefix}-${code_lower}-idp")

    for sub in "${subdomains[@]}"; do
        local fqdn="${sub}.${_base_domain}"

        # Check if record exists
        local existing
        existing=$(curl -s --max-time 10 \
            -H "Authorization: Bearer ${cf_token}" \
            -H "Content-Type: application/json" \
            "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records?name=${fqdn}&type=A" 2>/dev/null)

        local record_id
        record_id=$(echo "$existing" | jq -r '.result[0].id // empty' 2>/dev/null)

        if [ -n "$record_id" ]; then
            # Update existing record
            curl -s --max-time 10 -X PUT \
                -H "Authorization: Bearer ${cf_token}" \
                -H "Content-Type: application/json" \
                "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records/${record_id}" \
                -d "{\"type\":\"A\",\"name\":\"${fqdn}\",\"content\":\"${public_ip}\",\"ttl\":300,\"proxied\":false}" \
                >/dev/null 2>&1
            log_verbose "DNS updated: ${fqdn} → ${public_ip}"
        else
            # Create new record
            curl -s --max-time 10 -X POST \
                -H "Authorization: Bearer ${cf_token}" \
                -H "Content-Type: application/json" \
                "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records" \
                -d "{\"type\":\"A\",\"name\":\"${fqdn}\",\"content\":\"${public_ip}\",\"ttl\":300,\"proxied\":false}" \
                >/dev/null 2>&1
            log_verbose "DNS created: ${fqdn} → ${public_ip}"
        fi
    done

    log_success "Cloudflare DNS records set for ${code}: ${_env_prefix}-${code_lower}-{app,api,idp}.${_base_domain} → ${public_ip}"
}

##
# Reload Caddy to pick up new spoke configuration
##
spoke_caddy_reload() {
    local caddy_container="${COMPOSE_PROJECT_NAME:-dive-hub}-caddy"

    if ! docker ps --format '{{.Names}}' 2>/dev/null | grep -q "$caddy_container"; then
        log_warn "Caddy container '${caddy_container}' not running — skipping reload"
        return 0
    fi

    log_info "Reloading Caddy to pick up spoke configuration..."
    if docker exec "$caddy_container" caddy reload --config /etc/caddy/Caddyfile 2>/dev/null; then
        log_success "Caddy reloaded successfully"
    else
        log_warn "Caddy reload failed — may need manual restart: docker restart ${caddy_container}"
    fi
}

export -f spoke_caddy_setup
export -f spoke_caddy_generate_snippet
export -f spoke_caddy_create_dns
export -f spoke_caddy_reload
