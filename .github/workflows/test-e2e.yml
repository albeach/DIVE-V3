name: E2E Tests

on:
  push:
    branches: [main]
  workflow_dispatch:
  pull_request:
    branches: [main]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - '.github/workflows/test-e2e.yml'

jobs:
  e2e-authentication:
    name: E2E - Authentication Flows
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    services:
      mongodb:
        image: mongo:7.0
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --quiet --eval 'db.runCommand({ping:1}).ok' | grep 1"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      postgres:
        image: postgres:15
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: password
          POSTGRES_DB: dive_v3_app
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install Frontend Dependencies
        run: cd frontend && npm ci --legacy-peer-deps
      
      - name: Generate SSL Certificates for E2E
        run: |
          mkdir -p ${{ github.workspace }}/frontend/certs
          mkdir -p ${{ github.workspace }}/keycloak-certs
          
          # Frontend certificates
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/frontend/certs/key.pem \
            -out ${{ github.workspace }}/frontend/certs/certificate.pem \
            -days 365 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3/CN=localhost"
          
          # Keycloak certificates
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/keycloak-certs/key.pem \
            -out ${{ github.workspace }}/keycloak-certs/cert.pem \
            -days 1 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
            -addext "subjectAltName=DNS:localhost,DNS:keycloak,IP:127.0.0.1"
          
          # Make certificates readable by Keycloak container (runs as uid 1000)
          chmod 644 ${{ github.workspace }}/keycloak-certs/cert.pem
          chmod 644 ${{ github.workspace }}/keycloak-certs/key.pem
          
          echo "‚úÖ Generated self-signed SSL certificates for E2E testing"
          ls -la ${{ github.workspace }}/frontend/certs/
          ls -la ${{ github.workspace }}/keycloak-certs/

          # Generate OPA certificates
          mkdir -p ${{ github.workspace }}/certs
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/certs/key.pem \
            -out ${{ github.workspace }}/certs/certificate.pem \
            -days 1 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
            -addext "subjectAltName=DNS:localhost,DNS:opa,IP:127.0.0.1"

          echo "‚úÖ Generated OPA certificates"
          ls -la ${{ github.workspace }}/certs/
      
      - name: Start Keycloak 26.4.2 with HTTPS
        run: |
          echo "üöÄ Starting Keycloak 26.4.2 with HTTPS..."

          # Get the service network ID
          SERVICE_NETWORK=$(docker network ls -q -f name=github_network_)
          if [ -z "$SERVICE_NETWORK" ]; then
            SERVICE_NETWORK=$(docker network ls -q | head -1)
          fi
          echo "Using network: $SERVICE_NETWORK"

          docker run -d \
            --name keycloak \
            --network "$SERVICE_NETWORK" \
            -p 8443:8443 \
            -p 9000:9000 \
            -v ${{ github.workspace }}/keycloak-certs:/opt/keycloak/certs:ro \
            -e KC_DB=dev-mem \
            -e KC_LOG_LEVEL=info \
            -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \
            -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \
            -e KC_HEALTH_ENABLED=true \
            -e KC_HTTPS_CERTIFICATE_FILE=/opt/keycloak/certs/cert.pem \
            -e KC_HTTPS_CERTIFICATE_KEY_FILE=/opt/keycloak/certs/key.pem \
            -e KC_HOSTNAME_STRICT=false \
            -e KC_HTTP_ENABLED=false \
            quay.io/keycloak/keycloak:26.4.2 \
            start-dev --https-port=8443

          # Get Keycloak container IP for health checks
          KEYCLOAK_IP=$(docker inspect keycloak --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}')
          echo "KEYCLOAK_IP=$KEYCLOAK_IP" >> $GITHUB_ENV
          echo "‚úÖ Keycloak container started on network: $SERVICE_NETWORK with IP: $KEYCLOAK_IP on HTTPS port 8443"
      
      - name: Configure Keycloak for E2E Tests
        run: |
          echo "‚è≥ Waiting for Keycloak HTTPS to be ready..."
          echo "Using Keycloak IP: $KEYCLOAK_IP"
          # Wait for Keycloak management port to be accessible (simplified health check)
          for i in {1..60}; do
            if nc -z localhost 9000 2>/dev/null; then
              echo "‚úÖ Keycloak management port (9000) is accessible"
              # Additional check: try to access health endpoint if available
              if curl -k --max-time 5 https://localhost:9000/health/ready 2>/dev/null | grep -q "status.*UP\|true"; then
                echo "‚úÖ Keycloak health check passed"
                break
              else
                echo "‚ö†Ô∏è  Port accessible but health check inconclusive, continuing..."
                break
              fi
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå Keycloak failed to start after 5 minutes"
              echo "Checking container logs..."
              docker logs keycloak
              echo "Checking container status..."
              docker ps -a
              exit 1
            fi
            echo "Waiting for Keycloak... ($i/60)"
            sleep 5
          done

          # Configure realm and test users via Keycloak Admin REST API
          export KEYCLOAK_URL=https://localhost:8443
          export ACCESS_TOKEN=$(curl -k -s -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
            -d "client_id=admin-cli" \
            -d "username=admin" \
            -d "password=admin" \
            -d "grant_type=password" | jq -r '.access_token')
          
          # Create dive-v3-broker realm
          curl -k -s -X POST "$KEYCLOAK_URL/admin/realms" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"realm":"dive-v3-broker","enabled":true}' || echo "Realm may already exist"
          
          # Create test users with OTP configured
          # User 1: admin-dive (TOP_SECRET, needs MFA)
          curl -k -s -X POST "$KEYCLOAK_URL/admin/realms/dive-v3-broker/users" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "username":"admin-dive",
              "enabled":true,
              "credentials":[{"type":"password","value":"Admin123!","temporary":false}],
              "attributes":{"clearance":["TOP_SECRET"],"countryOfAffiliation":["USA"],"acpCOI":["FVEY","NATO"]}
            }' || echo "User admin-dive may already exist"
          
          # User 2: testuser-secret (SECRET, needs MFA, has OTP)
          curl -k -s -X POST "$KEYCLOAK_URL/admin/realms/dive-v3-broker/users" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "username":"testuser-secret",
              "enabled":true,
              "credentials":[{"type":"password","value":"Secret123!","temporary":false}],
              "attributes":{"clearance":["SECRET"],"countryOfAffiliation":["USA"],"acpCOI":["FVEY"]}
            }' || echo "User testuser-secret may already exist"
          
          # User 3: testuser-unclass (UNCLASSIFIED, no MFA)
          curl -k -s -X POST "$KEYCLOAK_URL/admin/realms/dive-v3-broker/users" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "username":"testuser-unclass",
              "enabled":true,
              "credentials":[{"type":"password","value":"Unclass123!","temporary":false}],
              "attributes":{"clearance":["UNCLASSIFIED"],"countryOfAffiliation":["USA"],"acpCOI":[]}
            }' || echo "User testuser-unclass may already exist"
          
          # User 4: testuser-us (for policies-lab tests)
          curl -k -s -X POST "$KEYCLOAK_URL/admin/realms/dive-v3-broker/users" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "username":"testuser-us",
              "enabled":true,
              "credentials":[{"type":"password","value":"password","temporary":false}],
              "attributes":{"clearance":["SECRET"],"countryOfAffiliation":["USA"],"acpCOI":["FVEY"]}
            }' || echo "User testuser-us may already exist"
          
          echo "‚úÖ Keycloak configured for E2E tests"
      
      - name: Initialize PostgreSQL Database Schema
        run: |
          # Run Drizzle migrations to set up NextAuth schema
          cd frontend
          npx drizzle-kit push:pg || echo "Database schema already exists"
        env:
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
      
      - name: Cache Playwright Browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('frontend/package-lock.json') }}
      
      - name: Install Playwright Browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: cd frontend && npx playwright install --with-deps chromium
      
      - name: Start Next.js Development Server
        run: |
          cd frontend

          # Set certificate path for custom HTTPS server
          export CERT_PATH="${{ github.workspace }}/frontend/certs"

          # Verify certificates exist before starting
          if [ ! -f "$CERT_PATH/certificate.pem" ] || [ ! -f "$CERT_PATH/key.pem" ]; then
            echo "‚ùå SSL certificates not found in $CERT_PATH"
            ls -la "$CERT_PATH" || echo "Directory does not exist"
            exit 1
          fi

          echo "‚úÖ SSL certificates found"

          # Start Next.js in background (HTTPS mode to match production)
          nohup npm run dev > nextjs.log 2>&1 &
          NEXTJS_PID=$!

          echo "Next.js started with PID: $NEXTJS_PID"

          # Wait for server to be ready with better error handling
          echo "‚è≥ Waiting for Next.js HTTPS server to be ready..."
          for i in {1..60}; do
            if curl -k --max-time 10 -f https://localhost:3000 2>/dev/null; then
              echo "‚úÖ Next.js HTTPS server is ready"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå Next.js failed to start after 2 minutes"
              echo "Checking Next.js logs:"
              cat nextjs.log
              echo ""
              echo "Checking if process is still running:"
              ps aux | grep "$NEXTJS_PID" || echo "Process not found"
              exit 1
            fi
            echo "Waiting for Next.js... ($i/60)"
            sleep 2
          done

          # Additional verification
          echo "Verifying Next.js is responding to requests..."
          curl -k -s -o /dev/null -w "%{http_code}" https://localhost:3000 | grep -q "200\|301\|302" && echo "‚úÖ Next.js responding correctly" || (echo "‚ùå Next.js not responding properly" && exit 1)
        env:
          NODE_ENV: development
          NEXTAUTH_URL: https://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-e2e-authentication-flows-2025
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
          KEYCLOAK_URL: https://localhost:8443
          KEYCLOAK_REALM: dive-v3-broker
          KEYCLOAK_CLIENT_ID: dive-v3-broker
          KEYCLOAK_CLIENT_SECRET: test-client-secret
          KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
          MONGODB_URL: mongodb://localhost:27017/dive-v3-test
      
      - name: Run Authentication E2E Tests
        run: cd frontend && npx playwright test src/__tests__/e2e/mfa-complete-flow.spec.ts src/__tests__/e2e/mfa-conditional.spec.ts src/__tests__/e2e/external-idp-federation-flow.spec.ts
        env:
          NODE_ENV: test
          NEXTAUTH_URL: https://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-e2e-authentication-flows-2025
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
          KEYCLOAK_URL: https://localhost:8443
          KEYCLOAK_REALM: dive-v3-broker
          KEYCLOAK_CLIENT_ID: dive-v3-broker
          KEYCLOAK_CLIENT_SECRET: test-client-secret
          KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
          MONGODB_URL: mongodb://localhost:27017/dive-v3-test
          BASE_URL: https://localhost:3000
          CI: true
          BACKEND_API_URL: http://localhost:4000
      
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-authentication-results
          path: |
            frontend/playwright-report/
            frontend/test-results/
          retention-days: 7

  e2e-authorization:
    name: E2E - Authorization Checks
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    services:
      mongodb:
        image: mongo:7.0
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --quiet --eval 'db.runCommand({ping:1}).ok' | grep 1"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      postgres:
        image: postgres:15
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: password
          POSTGRES_DB: dive_v3_app
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install Frontend Dependencies
        run: cd frontend && npm ci --legacy-peer-deps
      
      - name: Generate SSL Certificates for E2E
        run: |
          mkdir -p ${{ github.workspace }}/frontend/certs
          mkdir -p ${{ github.workspace }}/keycloak-certs
          
          # Frontend certificates
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/frontend/certs/key.pem \
            -out ${{ github.workspace }}/frontend/certs/certificate.pem \
            -days 365 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3/CN=localhost"
          
          # Keycloak certificates
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/keycloak-certs/key.pem \
            -out ${{ github.workspace }}/keycloak-certs/cert.pem \
            -days 1 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
            -addext "subjectAltName=DNS:localhost,DNS:keycloak,IP:127.0.0.1"
          
          # Make certificates readable by Keycloak container (runs as uid 1000)
          chmod 644 ${{ github.workspace }}/keycloak-certs/cert.pem
          chmod 644 ${{ github.workspace }}/keycloak-certs/key.pem
          
          echo "‚úÖ Generated self-signed SSL certificates for E2E testing"
          ls -la ${{ github.workspace }}/frontend/certs/
          ls -la ${{ github.workspace }}/keycloak-certs/

          # Generate OPA certificates
          mkdir -p ${{ github.workspace }}/certs
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/certs/key.pem \
            -out ${{ github.workspace }}/certs/certificate.pem \
            -days 1 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
            -addext "subjectAltName=DNS:localhost,DNS:opa,IP:127.0.0.1"

          echo "‚úÖ Generated OPA certificates"
          ls -la ${{ github.workspace }}/certs/
      
      - name: Start Keycloak 26.4.2 with HTTPS
        run: |
          echo "üöÄ Starting Keycloak 26.4.2 with HTTPS..."

          # Get the service network ID
          SERVICE_NETWORK=$(docker network ls -q -f name=github_network_)
          if [ -z "$SERVICE_NETWORK" ]; then
            SERVICE_NETWORK=$(docker network ls -q | head -1)
          fi
          echo "Using network: $SERVICE_NETWORK"

          docker run -d \
            --name keycloak \
            --network "$SERVICE_NETWORK" \
            -p 8443:8443 \
            -p 9000:9000 \
            -v ${{ github.workspace }}/keycloak-certs:/opt/keycloak/certs:ro \
            -e KC_DB=dev-mem \
            -e KC_LOG_LEVEL=info \
            -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \
            -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \
            -e KC_HEALTH_ENABLED=true \
            -e KC_HTTPS_CERTIFICATE_FILE=/opt/keycloak/certs/cert.pem \
            -e KC_HTTPS_CERTIFICATE_KEY_FILE=/opt/keycloak/certs/key.pem \
            -e KC_HOSTNAME_STRICT=false \
            -e KC_HTTP_ENABLED=false \
            quay.io/keycloak/keycloak:26.4.2 \
            start-dev --https-port=8443

          # Get Keycloak container IP for health checks
          KEYCLOAK_IP=$(docker inspect keycloak --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}')
          echo "KEYCLOAK_IP=$KEYCLOAK_IP" >> $GITHUB_ENV
          echo "‚úÖ Keycloak container started on network: $SERVICE_NETWORK with IP: $KEYCLOAK_IP on HTTPS port 8443"
      
      - name: Configure Keycloak for E2E Tests
        run: |
          echo "‚è≥ Waiting for Keycloak HTTPS to be ready..."
          echo "Using Keycloak IP: $KEYCLOAK_IP"
          # Wait for Keycloak management port to be accessible (simplified health check)
          for i in {1..60}; do
            if nc -z localhost 9000 2>/dev/null; then
              echo "‚úÖ Keycloak management port (9000) is accessible"
              # Additional check: try to access health endpoint if available
              if curl -k --max-time 5 https://localhost:9000/health/ready 2>/dev/null | grep -q "status.*UP\|true"; then
                echo "‚úÖ Keycloak health check passed"
                break
              else
                echo "‚ö†Ô∏è  Port accessible but health check inconclusive, continuing..."
                break
              fi
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå Keycloak failed to start after 5 minutes"
              echo "Checking container logs..."
              docker logs keycloak
              echo "Checking container status..."
              docker ps -a
              exit 1
            fi
            echo "Waiting for Keycloak... ($i/60)"
            sleep 5
          done

          export KEYCLOAK_URL=https://localhost:8443
          export ACCESS_TOKEN=$(curl -k -s -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
            -d "client_id=admin-cli" -d "username=admin" -d "password=admin" -d "grant_type=password" | jq -r '.access_token')
          
          curl -k -s -X POST "$KEYCLOAK_URL/admin/realms" \
            -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" \
            -d '{"realm":"dive-v3-broker","enabled":true}' || true
          
          for user in "admin-dive:Admin123!:TOP_SECRET" "testuser-us:password:SECRET"; do
            IFS=: read name pass clearance <<< "$user"
            curl -k -s -X POST "$KEYCLOAK_URL/admin/realms/dive-v3-broker/users" \
              -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" \
              -d "{\"username\":\"$name\",\"enabled\":true,\"credentials\":[{\"type\":\"password\",\"value\":\"$pass\",\"temporary\":false}],\"attributes\":{\"clearance\":[\"$clearance\"],\"countryOfAffiliation\":[\"USA\"],\"acpCOI\":[\"FVEY\"]}}" || true
          done
      
      - name: Initialize PostgreSQL Database Schema
        run: cd frontend && npx drizzle-kit push:pg || true
        env:
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
      
      - name: Cache Playwright Browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('frontend/package-lock.json') }}
      
      - name: Install Playwright Browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: cd frontend && npx playwright install --with-deps chromium
      
      - name: Start Next.js Development Server
        run: |
          cd frontend

          # Set certificate path for custom HTTPS server
          export CERT_PATH="${{ github.workspace }}/frontend/certs"

          # Verify certificates exist before starting
          if [ ! -f "$CERT_PATH/certificate.pem" ] || [ ! -f "$CERT_PATH/key.pem" ]; then
            echo "‚ùå SSL certificates not found in $CERT_PATH"
            ls -la "$CERT_PATH" || echo "Directory does not exist"
            exit 1
          fi

          echo "‚úÖ SSL certificates found"

          # Start Next.js in background (HTTPS mode to match production)
          nohup npm run dev > nextjs.log 2>&1 &
          NEXTJS_PID=$!

          echo "Next.js started with PID: $NEXTJS_PID"

          # Wait for server to be ready with better error handling
          echo "‚è≥ Waiting for Next.js HTTPS server to be ready..."
          for i in {1..60}; do
            if curl -k --max-time 10 -f https://localhost:3000 2>/dev/null; then
              echo "‚úÖ Next.js HTTPS server is ready"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå Next.js failed to start after 2 minutes"
              echo "Checking Next.js logs:"
              cat nextjs.log
              echo ""
              echo "Checking if process is still running:"
              ps aux | grep "$NEXTJS_PID" || echo "Process not found"
              exit 1
            fi
            echo "Waiting for Next.js... ($i/60)"
            sleep 2
          done

          # Additional verification
          echo "Verifying Next.js is responding to requests..."
          curl -k -s -o /dev/null -w "%{http_code}" https://localhost:3000 | grep -q "200\|301\|302" && echo "‚úÖ Next.js responding correctly" || (echo "‚ùå Next.js not responding properly" && exit 1)
        env:
          NODE_ENV: development
          NEXTAUTH_URL: https://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-e2e-authorization-2025
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
          KEYCLOAK_URL: https://localhost:8443
          KEYCLOAK_REALM: dive-v3-broker
          KEYCLOAK_CLIENT_ID: dive-v3-broker
          KEYCLOAK_CLIENT_SECRET: test-client-secret
          KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
          MONGODB_URL: mongodb://localhost:27017/dive-v3-test
      
      - name: Start OPA Server
        run: |
          curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64_static
          chmod +x opa
          nohup ./opa run --server --addr=:8181 --log-level=error --tls-cert-file=${{ github.workspace }}/certs/certificate.pem --tls-private-key-file=${{ github.workspace }}/certs/key.pem > opa.log 2>&1 &
          sleep 5
          curl -k -f https://localhost:8181/health || (cat opa.log && exit 1)
      
      - name: Run Authorization E2E Tests
        run: cd frontend && npx playwright test src/__tests__/e2e/identity-drawer.spec.ts
        env:
          NODE_ENV: test
          NEXTAUTH_URL: https://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-e2e-authorization-2025
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
          KEYCLOAK_URL: https://localhost:8443
          KEYCLOAK_REALM: dive-v3-broker
          KEYCLOAK_CLIENT_ID: dive-v3-broker
          KEYCLOAK_CLIENT_SECRET: test-client-secret
          KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
          MONGODB_URL: mongodb://localhost:27017/dive-v3-test
          OPA_URL: https://localhost:8181
          BASE_URL: https://localhost:3000
          CI: true
      
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-authorization-results
          path: |
            frontend/playwright-report/
            frontend/test-results/
          retention-days: 7

  e2e-classification-equivalency:
    name: E2E - Classification Equivalency
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    services:
      mongodb:
        image: mongo:7.0
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --quiet --eval 'db.runCommand({ping:1}).ok' | grep 1"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      postgres:
        image: postgres:15
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: password
          POSTGRES_DB: dive_v3_app
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      # NOTE: Keycloak service removed - using manual docker run in steps instead
      # Service containers don't support custom commands (start-dev required for KC 26.4.2)
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install Frontend Dependencies
        run: cd frontend && npm ci --legacy-peer-deps
      
      - name: Generate SSL Certificates for E2E
        run: |
          mkdir -p ${{ github.workspace }}/frontend/certs
          mkdir -p ${{ github.workspace }}/keycloak-certs
          
          # Frontend certificates
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/frontend/certs/key.pem \
            -out ${{ github.workspace }}/frontend/certs/certificate.pem \
            -days 365 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3/CN=localhost"
          
          # Keycloak certificates
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/keycloak-certs/key.pem \
            -out ${{ github.workspace }}/keycloak-certs/cert.pem \
            -days 1 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
            -addext "subjectAltName=DNS:localhost,DNS:keycloak,IP:127.0.0.1"
          
          # Make certificates readable by Keycloak container (runs as uid 1000)
          chmod 644 ${{ github.workspace }}/keycloak-certs/cert.pem
          chmod 644 ${{ github.workspace }}/keycloak-certs/key.pem
          
          echo "‚úÖ Generated self-signed SSL certificates for E2E testing"
          ls -la ${{ github.workspace }}/frontend/certs/
          ls -la ${{ github.workspace }}/keycloak-certs/

          # Generate OPA certificates
          mkdir -p ${{ github.workspace }}/certs
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/certs/key.pem \
            -out ${{ github.workspace }}/certs/certificate.pem \
            -days 1 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
            -addext "subjectAltName=DNS:localhost,DNS:opa,IP:127.0.0.1"

          echo "‚úÖ Generated OPA certificates"
          ls -la ${{ github.workspace }}/certs/
      - name: Start Keycloak 26.4.2 with HTTPS
        run: |
          echo "üöÄ Starting Keycloak 26.4.2 with HTTPS..."

          # Get the service network ID
          SERVICE_NETWORK=$(docker network ls -q -f name=github_network_)
          if [ -z "$SERVICE_NETWORK" ]; then
            SERVICE_NETWORK=$(docker network ls -q | head -1)
          fi
          echo "Using network: $SERVICE_NETWORK"

          docker run -d \
            --name keycloak \
            --network "$SERVICE_NETWORK" \
            -p 8443:8443 \
            -p 9000:9000 \
            -v ${{ github.workspace }}/keycloak-certs:/opt/keycloak/certs:ro \
            -e KC_DB=dev-mem \
            -e KC_LOG_LEVEL=info \
            -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \
            -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \
            -e KC_HEALTH_ENABLED=true \
            -e KC_HTTPS_CERTIFICATE_FILE=/opt/keycloak/certs/cert.pem \
            -e KC_HTTPS_CERTIFICATE_KEY_FILE=/opt/keycloak/certs/key.pem \
            -e KC_HOSTNAME_STRICT=false \
            -e KC_HTTP_ENABLED=false \
            quay.io/keycloak/keycloak:26.4.2 \
            start-dev --https-port=8443

          # Get Keycloak container IP for health checks
          KEYCLOAK_IP=$(docker inspect keycloak --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}')
          echo "KEYCLOAK_IP=$KEYCLOAK_IP" >> $GITHUB_ENV
          echo "‚úÖ Keycloak container started on network: $SERVICE_NETWORK with IP: $KEYCLOAK_IP on HTTPS port 8443"


      - name: Configure Keycloak for E2E Tests
        run: |
          echo "‚è≥ Waiting for Keycloak HTTPS to be ready..."
          # Wait for Keycloak management port to be accessible (simplified health check)
          for i in {1..60}; do
            if nc -z localhost 9000 2>/dev/null; then
              echo "‚úÖ Keycloak management port (9000) is accessible"
              # Additional check: try to access health endpoint if available
              if curl -k --max-time 5 https://localhost:9000/health/ready 2>/dev/null | grep -q "status.*UP\|true"; then
                echo "‚úÖ Keycloak health check passed"
                break
              else
                echo "‚ö†Ô∏è  Port accessible but health check inconclusive, continuing..."
                break
              fi
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå Keycloak failed to start after 5 minutes"
              docker logs keycloak
              docker ps -a
              exit 1
            fi
            echo "Waiting for Keycloak... ($i/60)"
            sleep 5
          done

          export KEYCLOAK_URL=https://localhost:8443
          export ACCESS_TOKEN=$(curl -k -s -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
            -d "client_id=admin-cli" -d "username=admin" -d "password=admin" -d "grant_type=password" | jq -r '.access_token')
          
          curl -k -s -X POST "$KEYCLOAK_URL/admin/realms" -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" \
            -d '{"realm":"dive-v3-broker","enabled":true}' || true
          
          for user in "admin-dive:Admin123!:TOP_SECRET" "testuser-us:password:SECRET"; do
            IFS=: read name pass clearance <<< "$user"
            curl -k -s -X POST "$KEYCLOAK_URL/admin/realms/dive-v3-broker/users" -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" \
              -d "{\"username\":\"$name\",\"enabled\":true,\"credentials\":[{\"type\":\"password\",\"value\":\"$pass\",\"temporary\":false}],\"attributes\":{\"clearance\":[\"$clearance\"],\"countryOfAffiliation\":[\"USA\"],\"acpCOI\":[\"FVEY\"]}}" || true
          done
          
          echo "‚úÖ Keycloak configured for E2E tests"
      
      - name: Initialize PostgreSQL Database Schema
        run: cd frontend && npx drizzle-kit push:pg || true
        env:
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
      
      - name: Cache Playwright Browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('frontend/package-lock.json') }}
      
      - name: Install Playwright Browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: cd frontend && npx playwright install --with-deps chromium

      - name: Start Next.js Development Server
        run: |
          cd frontend

          # Set certificate path for custom HTTPS server
          export CERT_PATH="${{ github.workspace }}/frontend/certs"

          # Verify certificates exist before starting
          if [ ! -f "$CERT_PATH/certificate.pem" ] || [ ! -f "$CERT_PATH/key.pem" ]; then
            echo "‚ùå SSL certificates not found in $CERT_PATH"
            ls -la "$CERT_PATH" || echo "Directory does not exist"
            exit 1
          fi

          echo "‚úÖ SSL certificates found"

          # Start Next.js in background (HTTPS mode to match production)
          nohup npm run dev > nextjs.log 2>&1 &
          NEXTJS_PID=$!

          echo "Next.js started with PID: $NEXTJS_PID"

          # Wait for server to be ready with better error handling
          echo "‚è≥ Waiting for Next.js HTTPS server to be ready..."
          for i in {1..60}; do
            if curl -k --max-time 10 -f https://localhost:3000 2>/dev/null; then
              echo "‚úÖ Next.js HTTPS server is ready"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå Next.js failed to start after 2 minutes"
              echo "Checking Next.js logs:"
              cat nextjs.log
              echo ""
              echo "Checking if process is still running:"
              ps aux | grep "$NEXTJS_PID" || echo "Process not found"
              exit 1
            fi
            echo "Waiting for Next.js... ($i/60)"
            sleep 2
          done

          # Additional verification
          echo "Verifying Next.js is responding to requests..."
          curl -k -s -o /dev/null -w "%{http_code}" https://localhost:3000 | grep -q "200\|301\|302" && echo "‚úÖ Next.js responding correctly" || (echo "‚ùå Next.js not responding properly" && exit 1)
        env:
          NODE_ENV: development
          NEXTAUTH_URL: https://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-e2e-classification-2025
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
          KEYCLOAK_URL: https://localhost:8443
          KEYCLOAK_REALM: dive-v3-broker
          KEYCLOAK_CLIENT_ID: dive-v3-broker
          KEYCLOAK_CLIENT_SECRET: test-client-secret
          KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
          MONGODB_URL: mongodb://localhost:27017/dive-v3-test
      
      - name: Run Classification Equivalency E2E Tests
        run: cd frontend && npx playwright test src/__tests__/e2e/classification-equivalency.spec.ts src/__tests__/e2e/integration-federation-vs-object.spec.ts
        env:
          NODE_ENV: test
          NEXTAUTH_URL: https://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-e2e-classification-2025
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
          KEYCLOAK_URL: https://localhost:8443
          KEYCLOAK_REALM: dive-v3-broker
          KEYCLOAK_CLIENT_ID: dive-v3-broker
          KEYCLOAK_CLIENT_SECRET: test-client-secret
          KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
          MONGODB_URL: mongodb://localhost:27017/dive-v3-test
          BASE_URL: https://localhost:3000
          CI: true
      
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-classification-results
          path: |
            frontend/playwright-report/
            frontend/test-results/
          retention-days: 7

  e2e-resource-management:
    name: E2E - Resource Management
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    services:
      mongodb:
        image: mongo:7.0
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --quiet --eval 'db.runCommand({ping:1}).ok' | grep 1"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      postgres:
        image: postgres:15
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: password
          POSTGRES_DB: dive_v3_app
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      # NOTE: Keycloak service removed - using manual docker run in steps instead
      # Service containers don't support custom commands (start-dev required for KC 26.4.2)
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install Frontend Dependencies
        run: cd frontend && npm ci --legacy-peer-deps
      
      - name: Generate SSL Certificates for E2E
        run: |
          mkdir -p ${{ github.workspace }}/frontend/certs
          mkdir -p ${{ github.workspace }}/keycloak-certs
          
          # Frontend certificates
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/frontend/certs/key.pem \
            -out ${{ github.workspace }}/frontend/certs/certificate.pem \
            -days 365 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3/CN=localhost"
          
          # Keycloak certificates
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/keycloak-certs/key.pem \
            -out ${{ github.workspace }}/keycloak-certs/cert.pem \
            -days 1 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
            -addext "subjectAltName=DNS:localhost,DNS:keycloak,IP:127.0.0.1"
          
          # Make certificates readable by Keycloak container (runs as uid 1000)
          chmod 644 ${{ github.workspace }}/keycloak-certs/cert.pem
          chmod 644 ${{ github.workspace }}/keycloak-certs/key.pem
          
          echo "‚úÖ Generated self-signed SSL certificates for E2E testing"
          ls -la ${{ github.workspace }}/frontend/certs/
          ls -la ${{ github.workspace }}/keycloak-certs/

          # Generate OPA certificates
          mkdir -p ${{ github.workspace }}/certs
          openssl req -x509 -newkey rsa:4096 -nodes \
            -keyout ${{ github.workspace }}/certs/key.pem \
            -out ${{ github.workspace }}/certs/certificate.pem \
            -days 1 \
            -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
            -addext "subjectAltName=DNS:localhost,DNS:opa,IP:127.0.0.1"

          echo "‚úÖ Generated OPA certificates"
          ls -la ${{ github.workspace }}/certs/
      - name: Start Keycloak 26.4.2 with HTTPS
        run: |
          echo "üöÄ Starting Keycloak 26.4.2 with HTTPS..."

          # Get the service network ID
          SERVICE_NETWORK=$(docker network ls -q -f name=github_network_)
          if [ -z "$SERVICE_NETWORK" ]; then
            SERVICE_NETWORK=$(docker network ls -q | head -1)
          fi
          echo "Using network: $SERVICE_NETWORK"

          docker run -d \
            --name keycloak \
            --network "$SERVICE_NETWORK" \
            -p 8443:8443 \
            -p 9000:9000 \
            -v ${{ github.workspace }}/keycloak-certs:/opt/keycloak/certs:ro \
            -e KC_DB=dev-mem \
            -e KC_LOG_LEVEL=info \
            -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \
            -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \
            -e KC_HEALTH_ENABLED=true \
            -e KC_HTTPS_CERTIFICATE_FILE=/opt/keycloak/certs/cert.pem \
            -e KC_HTTPS_CERTIFICATE_KEY_FILE=/opt/keycloak/certs/key.pem \
            -e KC_HOSTNAME_STRICT=false \
            -e KC_HTTP_ENABLED=false \
            quay.io/keycloak/keycloak:26.4.2 \
            start-dev --https-port=8443

          # Get Keycloak container IP for health checks
          KEYCLOAK_IP=$(docker inspect keycloak --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}')
          echo "KEYCLOAK_IP=$KEYCLOAK_IP" >> $GITHUB_ENV
          echo "‚úÖ Keycloak container started on network: $SERVICE_NETWORK with IP: $KEYCLOAK_IP on HTTPS port 8443"
      
          echo "‚úÖ Generated self-signed SSL certificates for E2E testing"

      - name: Configure Keycloak for E2E Tests
        run: |
          echo "‚è≥ Waiting for Keycloak HTTPS to be ready..."
          # Wait for Keycloak management port to be accessible (simplified health check)
          for i in {1..60}; do
            if nc -z localhost 9000 2>/dev/null; then
              echo "‚úÖ Keycloak management port (9000) is accessible"
              # Additional check: try to access health endpoint if available
              if curl -k --max-time 5 https://localhost:9000/health/ready 2>/dev/null | grep -q "status.*UP\|true"; then
                echo "‚úÖ Keycloak health check passed"
                break
              else
                echo "‚ö†Ô∏è  Port accessible but health check inconclusive, continuing..."
                break
              fi
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå Keycloak failed to start after 5 minutes"
              docker logs keycloak
              docker ps -a
              exit 1
            fi
            echo "Waiting for Keycloak... ($i/60)"
            sleep 5
          done
          
          export KEYCLOAK_URL=https://localhost:8443
          export ACCESS_TOKEN=$(curl -k -s -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
            -d "client_id=admin-cli" -d "username=admin" -d "password=admin" -d "grant_type=password" | jq -r '.access_token')
          
          curl -k -s -X POST "$KEYCLOAK_URL/admin/realms" -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" \
            -d '{"realm":"dive-v3-broker","enabled":true}' || true
          
          for user in "admin-dive:Admin123!:TOP_SECRET" "testuser-us:password:SECRET"; do
            IFS=: read name pass clearance <<< "$user"
            curl -k -s -X POST "$KEYCLOAK_URL/admin/realms/dive-v3-broker/users" -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" \
              -d "{\"username\":\"$name\",\"enabled\":true,\"credentials\":[{\"type\":\"password\",\"value\":\"$pass\",\"temporary\":false}],\"attributes\":{\"clearance\":[\"$clearance\"],\"countryOfAffiliation\":[\"USA\"],\"acpCOI\":[\"FVEY\"]}}" || true
          done
          
          echo "‚úÖ Keycloak configured for E2E tests"
      
      - name: Initialize PostgreSQL Database Schema
        run: cd frontend && npx drizzle-kit push:pg || true
        env:
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
      
      - name: Cache Playwright Browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('frontend/package-lock.json') }}
      
      - name: Install Playwright Browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: cd frontend && npx playwright install --with-deps chromium

      - name: Start Next.js Development Server
        run: |
          cd frontend

          # Set certificate path for custom HTTPS server
          export CERT_PATH="${{ github.workspace }}/frontend/certs"

          # Verify certificates exist before starting
          if [ ! -f "$CERT_PATH/certificate.pem" ] || [ ! -f "$CERT_PATH/key.pem" ]; then
            echo "‚ùå SSL certificates not found in $CERT_PATH"
            ls -la "$CERT_PATH" || echo "Directory does not exist"
            exit 1
          fi

          echo "‚úÖ SSL certificates found"

          # Start Next.js in background (HTTPS mode to match production)
          nohup npm run dev > nextjs.log 2>&1 &
          NEXTJS_PID=$!

          echo "Next.js started with PID: $NEXTJS_PID"

          # Wait for server to be ready with better error handling
          echo "‚è≥ Waiting for Next.js HTTPS server to be ready..."
          for i in {1..60}; do
            if curl -k --max-time 10 -f https://localhost:3000 2>/dev/null; then
              echo "‚úÖ Next.js HTTPS server is ready"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå Next.js failed to start after 2 minutes"
              echo "Checking Next.js logs:"
              cat nextjs.log
              echo ""
              echo "Checking if process is still running:"
              ps aux | grep "$NEXTJS_PID" || echo "Process not found"
              exit 1
            fi
            echo "Waiting for Next.js... ($i/60)"
            sleep 2
          done

          # Additional verification
          echo "Verifying Next.js is responding to requests..."
          curl -k -s -o /dev/null -w "%{http_code}" https://localhost:3000 | grep -q "200\|301\|302" && echo "‚úÖ Next.js responding correctly" || (echo "‚ùå Next.js not responding properly" && exit 1)
        env:
          NODE_ENV: development
          NEXTAUTH_URL: https://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-e2e-resource-2025
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
          KEYCLOAK_URL: https://localhost:8443
          KEYCLOAK_REALM: dive-v3-broker
          KEYCLOAK_CLIENT_ID: dive-v3-broker
          KEYCLOAK_CLIENT_SECRET: test-client-secret
          KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
          MONGODB_URL: mongodb://localhost:27017/dive-v3-test
      
      - name: Start OPA Server
        run: |
          curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64_static
          chmod +x opa
          nohup ./opa run --server --addr=:8181 --log-level=error --tls-cert-file=${{ github.workspace }}/certs/certificate.pem --tls-private-key-file=${{ github.workspace }}/certs/key.pem > opa.log 2>&1 &
          sleep 5
          curl -k -f https://localhost:8181/health || (cat opa.log && exit 1)
      
      - name: Run Resource Management E2E Tests
        run: cd frontend && npx playwright test src/__tests__/e2e/policies-lab.spec.ts src/__tests__/e2e/nato-expansion.spec.ts src/__tests__/e2e/idp-management-revamp.spec.ts tests/e2e/sp-registry.spec.ts
        env:
          NODE_ENV: test
          NEXTAUTH_URL: https://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-e2e-resource-2025
          DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
          KEYCLOAK_URL: https://localhost:8443
          KEYCLOAK_REALM: dive-v3-broker
          KEYCLOAK_CLIENT_ID: dive-v3-broker
          KEYCLOAK_CLIENT_SECRET: test-client-secret
          KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
          MONGODB_URL: mongodb://localhost:27017/dive-v3-test
          OPA_URL: https://localhost:8181
          BASE_URL: https://localhost:3000
          CI: true
      
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-resource-results
          path: |
            frontend/playwright-report/
            frontend/test-results/
          retention-days: 7

  e2e-summary:
    name: E2E Test Summary
    runs-on: ubuntu-latest
    needs: [e2e-authentication, e2e-authorization, e2e-classification-equivalency, e2e-resource-management]
    if: always()
    
    steps:
      - name: Generate Summary
        run: |
          echo "## üé≠ E2E Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test Suite | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Authentication | ${{ needs.e2e-authentication.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Authorization | ${{ needs.e2e-authorization.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Classification Equivalency | ${{ needs.e2e-classification-equivalency.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Management | ${{ needs.e2e-resource-management.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Test artifacts available in workflow artifacts" >> $GITHUB_STEP_SUMMARY

