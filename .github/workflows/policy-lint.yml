name: Policy Lint & Quality Check

on:
  push:
    branches: [main, develop]
    paths:
      - 'policies/**/*.rego'
      - 'scripts/policy/regal-config.yaml'
  pull_request:
    branches: [main]
    paths:
      - 'policies/**/*.rego'
      - 'scripts/policy/regal-config.yaml'
  workflow_dispatch:

env:
  OPA_VERSION: '0.68.0'
  REGAL_VERSION: '0.24.0'

jobs:
  # ============================================
  # Stage 1: Syntax Validation
  # ============================================
  syntax:
    name: Rego Syntax Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: ${{ env.OPA_VERSION }}

      - name: Check Rego Syntax
        run: |
          echo "üîç Checking Rego syntax..."
          opa check policies/ --strict
          echo "‚úÖ Syntax validation passed"

      - name: Parse All Policies
        run: |
          echo "üìù Parsing all policies..."
          opa parse policies/**/*.rego
          echo "‚úÖ All policies parse successfully"

  # ============================================
  # Stage 2: Regal Linting
  # ============================================
  lint:
    name: Regal Policy Lint
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: syntax
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Regal
        run: |
          curl -L -o regal "https://github.com/StyraInc/regal/releases/download/v${{ env.REGAL_VERSION }}/regal_Linux_x86_64"
          chmod +x regal
          sudo mv regal /usr/local/bin/
          regal version

      - name: Run Regal Lint
        id: lint
        run: |
          echo "üîç Running Regal linter..."
          
          # Run with custom config if exists
          if [ -f "scripts/policy/regal-config.yaml" ]; then
            regal lint policies/ --config scripts/policy/regal-config.yaml --format=json > lint-results.json || true
          else
            regal lint policies/ --format=json > lint-results.json || true
          fi
          
          # Count issues
          ERRORS=$(jq '[.violations[] | select(.level == "error")] | length' lint-results.json 2>/dev/null || echo "0")
          WARNINGS=$(jq '[.violations[] | select(.level == "warning")] | length' lint-results.json 2>/dev/null || echo "0")
          
          echo "errors=${ERRORS}" >> $GITHUB_OUTPUT
          echo "warnings=${WARNINGS}" >> $GITHUB_OUTPUT
          
          echo "üìä Lint results: ${ERRORS} errors, ${WARNINGS} warnings"

      - name: Generate Lint Report
        run: |
          echo "## üìã Regal Lint Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          ERRORS=${{ steps.lint.outputs.errors }}
          WARNINGS=${{ steps.lint.outputs.warnings }}
          
          if [ "${ERRORS}" -gt 0 ]; then
            echo "### ‚ùå Errors (${ERRORS})" >> $GITHUB_STEP_SUMMARY
            jq -r '.violations[] | select(.level == "error") | "- **\(.rule)**: \(.description) (\(.location.file):\(.location.row))"' lint-results.json >> $GITHUB_STEP_SUMMARY || true
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${WARNINGS}" -gt 0 ]; then
            echo "### ‚ö†Ô∏è Warnings (${WARNINGS})" >> $GITHUB_STEP_SUMMARY
            jq -r '.violations[] | select(.level == "warning") | "- **\(.rule)**: \(.description) (\(.location.file):\(.location.row))"' lint-results.json >> $GITHUB_STEP_SUMMARY || true
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${ERRORS}" -eq 0 ] && [ "${WARNINGS}" -eq 0 ]; then
            echo "### ‚úÖ No Issues Found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All policies pass linting checks." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload Lint Results
        uses: actions/upload-artifact@v4
        with:
          name: lint-results
          path: lint-results.json
          retention-days: 30

      - name: Fail on Errors
        if: steps.lint.outputs.errors > 0
        run: |
          echo "‚ùå Lint check failed with ${{ steps.lint.outputs.errors }} error(s)"
          jq '.violations[] | select(.level == "error")' lint-results.json
          exit 1

  # ============================================
  # Stage 3: DIVE V3 Custom Checks
  # ============================================
  dive-checks:
    name: DIVE V3 Custom Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: syntax
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Check Package Naming Convention
        id: package-check
        run: |
          echo "üîç Checking package naming convention..."
          
          VIOLATIONS=""
          VIOLATION_COUNT=0
          
          for file in $(find policies -name "*.rego" -type f ! -name "*_test.rego"); do
            PACKAGE=$(grep -m1 "^package" "$file" 2>/dev/null | awk '{print $2}' || true)
            
            if [ -n "$PACKAGE" ]; then
              # Check if package starts with dive. (except for data. packages)
              if [[ ! "$PACKAGE" =~ ^dive\. ]] && [[ ! "$PACKAGE" =~ ^data\. ]]; then
                VIOLATIONS="${VIOLATIONS}\n  - ${file}: package ${PACKAGE}"
                VIOLATION_COUNT=$((VIOLATION_COUNT + 1))
              fi
            fi
          done
          
          echo "violation_count=${VIOLATION_COUNT}" >> $GITHUB_OUTPUT
          
          if [ ${VIOLATION_COUNT} -gt 0 ]; then
            echo "‚ùå Found ${VIOLATION_COUNT} package naming violations:"
            echo -e "${VIOLATIONS}"
            exit 1
          fi
          
          echo "‚úÖ All packages follow naming convention"

      - name: Check for Hardcoded Secrets
        run: |
          echo "üîç Scanning for hardcoded secrets..."
          
          # Patterns to check (excluding test files)
          PATTERNS=(
            'password\s*:=\s*"'
            'secret\s*:=\s*"'
            'api_key\s*:=\s*"'
            'token\s*:=\s*"'
          )
          
          FOUND=0
          for pattern in "${PATTERNS[@]}"; do
            MATCHES=$(grep -rn "$pattern" policies/*.rego 2>/dev/null | grep -v "_test.rego" || true)
            if [ -n "$MATCHES" ]; then
              echo "‚ö†Ô∏è Potential secret found with pattern: $pattern"
              echo "$MATCHES"
              FOUND=1
            fi
          done
          
          if [ $FOUND -eq 1 ]; then
            echo "‚ùå Potential hardcoded secrets detected!"
            exit 1
          fi
          
          echo "‚úÖ No hardcoded secrets found"

      - name: Check Default Deny Pattern
        run: |
          echo "üîç Checking for default deny pattern..."
          
          # Find main authorization files
          AUTH_FILES=$(find policies -name "*.rego" -type f | xargs grep -l "^default allow" 2>/dev/null || true)
          
          if [ -z "$AUTH_FILES" ]; then
            echo "‚ö†Ô∏è No files with 'default allow' found"
          else
            for file in $AUTH_FILES; do
              # Check that default allow is false
              if grep -q "default allow\s*:=\s*true" "$file"; then
                echo "‚ùå CRITICAL: Found 'default allow := true' in $file"
                echo "   ACP-240 requires default deny (default allow := false)"
                exit 1
              fi
            done
            echo "‚úÖ Default deny pattern verified"
          fi

      - name: Check Country Code Format
        run: |
          echo "üîç Checking country code format..."
          
          # ISO 3166-1 alpha-3 codes we use
          VALID_CODES="USA|FRA|GBR|DEU|CAN|ESP|ITA|NLD|BEL|NOR|DNK|POL|PRT"
          
          # Invalid 2-letter codes that might be mistakenly used
          INVALID_PATTERNS=(
            '"\<US\>"'
            '"\<FR\>"'
            '"\<GB\>"'
            '"\<DE\>"'
            '"\<CA\>"'
            '"\<ES\>"'
          )
          
          FOUND=0
          for pattern in "${INVALID_PATTERNS[@]}"; do
            MATCHES=$(grep -rn "$pattern" policies/*.rego 2>/dev/null | grep -v "_test.rego" | grep -v "# alpha-2 ok" || true)
            if [ -n "$MATCHES" ]; then
              echo "‚ö†Ô∏è Found 2-letter country code:"
              echo "$MATCHES"
              FOUND=1
            fi
          done
          
          if [ $FOUND -eq 1 ]; then
            echo "‚ùå Use ISO 3166-1 alpha-3 codes (USA, FRA, GBR, DEU, CAN)"
            # Warning only, don't fail
          fi
          
          echo "‚úÖ Country code check complete"

      - name: Check Test File Coverage
        run: |
          echo "üîç Checking test file coverage..."
          
          # Get all non-test rego files with rules
          RULE_FILES=$(find policies -name "*.rego" -type f ! -name "*_test.rego" ! -path "*/baselines/*")
          
          MISSING_TESTS=0
          TOTAL_FILES=0
          
          for file in $RULE_FILES; do
            # Skip data files and config files
            if grep -q "^package.*\.data$" "$file" 2>/dev/null; then
              continue
            fi
            
            TOTAL_FILES=$((TOTAL_FILES + 1))
            
            # Check for corresponding test file
            TEST_FILE="${file%.rego}_test.rego"
            DIR_TEST_FILE=$(dirname "$file")/test_$(basename "$file")
            
            if [ ! -f "$TEST_FILE" ] && [ ! -f "$DIR_TEST_FILE" ]; then
              # Check if there's any test file in the same directory
              DIR=$(dirname "$file")
              TESTS_IN_DIR=$(find "$DIR" -name "*_test.rego" -type f 2>/dev/null | wc -l | tr -d ' ')
              
              if [ "$TESTS_IN_DIR" -eq 0 ]; then
                echo "‚ö†Ô∏è No test file for: $file"
                MISSING_TESTS=$((MISSING_TESTS + 1))
              fi
            fi
          done
          
          COVERAGE_PCT=$((100 - (MISSING_TESTS * 100 / TOTAL_FILES)))
          echo "üìä Test file coverage: ${COVERAGE_PCT}% (${TOTAL_FILES} files, ${MISSING_TESTS} without tests)"
          
          if [ $COVERAGE_PCT -lt 50 ]; then
            echo "‚ö†Ô∏è Warning: Test coverage below 50%"
          else
            echo "‚úÖ Test coverage acceptable"
          fi

      - name: Generate Summary
        run: |
          echo "## üîç DIVE V3 Custom Checks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Package Naming | ‚úÖ Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| Hardcoded Secrets | ‚úÖ Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| Default Deny Pattern | ‚úÖ Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| Country Code Format | ‚úÖ Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| Test Coverage | ‚ö†Ô∏è See details |" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Stage 4: Combined Quality Gate
  # ============================================
  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    needs: [syntax, lint, dive-checks]
    if: always()
    
    steps:
      - name: Check Results
        run: |
          if [ "${{ needs.syntax.result }}" = "failure" ]; then
            echo "‚ùå Syntax check failed"
            exit 1
          fi
          
          if [ "${{ needs.lint.result }}" = "failure" ]; then
            echo "‚ùå Lint check failed"
            exit 1
          fi
          
          if [ "${{ needs.dive-checks.result }}" = "failure" ]; then
            echo "‚ùå DIVE V3 custom checks failed"
            exit 1
          fi
          
          echo "‚úÖ All quality checks passed"

      - name: Summary
        run: |
          echo "## ‚úÖ Policy Quality Gate Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All policy lint and quality checks have passed." >> $GITHUB_STEP_SUMMARY





