name: 'E2E Test Setup'
description: 'Shared setup for DIVE V3 E2E test jobs: Node.js, deps, SSL, Keycloak, PostgreSQL, backend HTTPS, Playwright, Next.js HTTPS, optional OPA'

inputs:
  nextauth-secret:
    description: 'NEXTAUTH_SECRET for the Next.js server'
    required: true
  keycloak-users:
    description: 'JSON array of Keycloak user configs. Each: {"username":"...","password":"...","clearance":"...","coi":[...]}'
    required: false
    default: '[{"username":"admin-dive","password":"Admin123!","clearance":"TOP_SECRET","coi":[]},{"username":"testuser-unclass","password":"Unclass123!","clearance":"UNCLASSIFIED","coi":[]}]'
  start-opa:
    description: 'Whether to start OPA server (true/false)'
    required: false
    default: 'false'

runs:
  using: composite
  steps:
    - name: Setup Node.js 20
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: |
          frontend/package-lock.json
          backend/package-lock.json

    - name: Install Frontend Dependencies
      shell: bash
      run: cd frontend && npm ci --legacy-peer-deps

    - name: Install Backend Dependencies
      shell: bash
      run: cd backend && npm ci --legacy-peer-deps

    - name: Generate SSL Certificates
      shell: bash
      run: |
        mkdir -p ${{ github.workspace }}/frontend/certs \
                 ${{ github.workspace }}/keycloak-certs \
                 ${{ github.workspace }}/certs

        # Frontend certificates
        openssl req -x509 -newkey rsa:4096 -nodes \
          -keyout ${{ github.workspace }}/frontend/certs/key.pem \
          -out ${{ github.workspace }}/frontend/certs/certificate.pem \
          -days 1 -subj "/C=US/ST=Test/L=Test/O=DIVE V3/CN=localhost"

        # Keycloak certificates
        openssl req -x509 -newkey rsa:4096 -nodes \
          -keyout ${{ github.workspace }}/keycloak-certs/key.pem \
          -out ${{ github.workspace }}/keycloak-certs/cert.pem \
          -days 1 -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
          -addext "subjectAltName=DNS:localhost,DNS:keycloak,IP:127.0.0.1"
        chmod 644 ${{ github.workspace }}/keycloak-certs/cert.pem \
                  ${{ github.workspace }}/keycloak-certs/key.pem

        # OPA certificates (always generated for simplicity)
        openssl req -x509 -newkey rsa:4096 -nodes \
          -keyout ${{ github.workspace }}/certs/key.pem \
          -out ${{ github.workspace }}/certs/certificate.pem \
          -days 1 -subj "/C=US/ST=Test/L=Test/O=DIVE V3 CI/CN=localhost" \
          -addext "subjectAltName=DNS:localhost,DNS:opa,IP:127.0.0.1"

        # Build a CA bundle for Node-based services that must trust multiple
        # self-signed certs in CI (frontend/backend HTTPS + Keycloak HTTPS).
        cat ${{ github.workspace }}/frontend/certs/certificate.pem \
            ${{ github.workspace }}/keycloak-certs/cert.pem \
            > ${{ github.workspace }}/certs/ca-bundle.pem

        echo "::notice::SSL certificates generated"

    - name: Start Keycloak
      shell: bash
      run: |
        docker run -d --name keycloak \
          -p 8443:8443 \
          -p 9000:9000 \
          -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \
          -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \
          -e KC_HTTPS_CERTIFICATE_FILE=/opt/keycloak/certs/cert.pem \
          -e KC_HTTPS_CERTIFICATE_KEY_FILE=/opt/keycloak/certs/key.pem \
          -e KC_HEALTH_ENABLED=true \
          -e KC_HOSTNAME_STRICT=false \
          -v ${{ github.workspace }}/keycloak-certs:/opt/keycloak/certs:ro \
          quay.io/keycloak/keycloak:26.4.2 start-dev

        max_attempts=300
        for i in $(seq 1 "$max_attempts"); do
          # Keycloak health endpoints are served on management port 9000.
          if curl -kfsS https://localhost:9000/health/ready >/dev/null 2>&1; then
            echo "::notice::Keycloak management health ready"
            break
          fi

          # Fallback: confirm the public OIDC endpoint is reachable.
          if curl -kfsS https://localhost:8443/realms/master/.well-known/openid-configuration >/dev/null 2>&1; then
            echo "::notice::Keycloak OIDC endpoint ready"
            break
          fi

          if ! docker ps --filter "name=^/keycloak$" --filter "status=running" --format '{{.Names}}' | grep -q '^keycloak$'; then
            echo "::error::Keycloak container exited before becoming ready"
            docker logs --tail 300 keycloak || true
            exit 1
          fi

          if [ "$i" -eq "$max_attempts" ]; then
            echo "::error::Keycloak failed to become ready after 10 minutes"
            docker logs --tail 300 keycloak
            exit 1
          fi
          sleep 2
        done

    - name: Configure Keycloak Realm and Users
      shell: bash
      run: |
        TOKEN=""
        for i in {1..30}; do
          TOKEN=$(curl -sk -X POST https://localhost:8443/realms/master/protocol/openid-connect/token \
            -d "client_id=admin-cli&username=admin&password=admin&grant_type=password" | jq -r '.access_token // empty')
          if [ -n "$TOKEN" ]; then
            break
          fi
          sleep 2
        done

        if [ -z "$TOKEN" ]; then
          echo "::error::Failed to obtain Keycloak admin token"
          docker logs --tail 300 keycloak
          exit 1
        fi

        REALM="dive-v3-broker-usa"

        # Create realm
        curl -sk -X POST https://localhost:8443/admin/realms \
          -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
          -d "{\"realm\":\"$REALM\",\"enabled\":true}" || true

        # Create OIDC client for NextAuth
        curl -sk -X POST "https://localhost:8443/admin/realms/$REALM/clients" \
          -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
          -d '{
            "clientId": "dive-v3-broker-usa",
            "enabled": true,
            "protocol": "openid-connect",
            "publicClient": false,
            "secret": "test-client-secret",
            "redirectUris": ["https://localhost:3000/*"],
            "webOrigins": ["https://localhost:3000"],
            "directAccessGrantsEnabled": true,
            "standardFlowEnabled": true
          }' || true
        echo "::notice::OIDC client created in $REALM"

        CLIENT_UUID=$(curl -sk "https://localhost:8443/admin/realms/$REALM/clients?clientId=dive-v3-broker-usa" \
          -H "Authorization: Bearer $TOKEN" | jq -r '.[0].id // empty')
        if [ -z "$CLIENT_UUID" ]; then
          echo "::error::Failed to resolve Keycloak client UUID for dive-v3-broker-usa"
          exit 1
        fi

        # Ensure all scopes requested by NextAuth are available for the client.
        # Missing scopes cause Keycloak invalid_scope and immediate auth callback failure.
        for scope in openid profile email uniqueID clearance countryOfAffiliation acpCOI user_acr user_amr; do
          SCOPE_ID=$(curl -sk "https://localhost:8443/admin/realms/$REALM/client-scopes" \
            -H "Authorization: Bearer $TOKEN" | jq -r ".[] | select(.name == \"$scope\") | .id" | head -n1)

          if [ -z "$SCOPE_ID" ]; then
            curl -sk -X POST "https://localhost:8443/admin/realms/$REALM/client-scopes" \
              -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
              -d "{\"name\":\"$scope\",\"protocol\":\"openid-connect\",\"attributes\":{\"include.in.token.scope\":\"true\",\"display.on.consent.screen\":\"false\"}}" || true
            SCOPE_ID=$(curl -sk "https://localhost:8443/admin/realms/$REALM/client-scopes" \
              -H "Authorization: Bearer $TOKEN" | jq -r ".[] | select(.name == \"$scope\") | .id" | head -n1)
          fi

          if [ -n "$SCOPE_ID" ]; then
            curl -sk -X PUT "https://localhost:8443/admin/realms/$REALM/clients/$CLIENT_UUID/default-client-scopes/$SCOPE_ID" \
              -H "Authorization: Bearer $TOKEN" >/dev/null 2>&1 || true
            echo "::notice::Ensured client scope on dive-v3-broker-usa: $scope"
          else
            echo "::warning::Unable to resolve/create client scope: $scope"
          fi
        done

        # Disable first-login required actions that break unattended Playwright login.
        for alias in UPDATE_PROFILE VERIFY_EMAIL; do
          ACTION_JSON=$(curl -sk "https://localhost:8443/admin/realms/$REALM/authentication/required-actions" \
            -H "Authorization: Bearer $TOKEN" | jq -c ".[] | select(.alias == \"$alias\")" | head -n1)
          if [ -n "$ACTION_JSON" ]; then
            curl -sk -X PUT "https://localhost:8443/admin/realms/$REALM/authentication/required-actions/$alias" \
              -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
              -d "$(echo "$ACTION_JSON" | jq '.defaultAction=false')" >/dev/null 2>&1 || true
            echo "::notice::Disabled default required action: $alias"
          fi
        done

        upsert_user() {
          local username="$1"
          local password="$2"
          local clearance="$3"
          local coi_json="$4"
          local first_name="$5"
          local last_name="$6"
          local email="$7"
          local country="$8"

          local user_payload
          user_payload=$(jq -cn \
            --arg username "$username" \
            --arg first_name "$first_name" \
            --arg last_name "$last_name" \
            --arg email "$email" \
            --arg clearance "$clearance" \
            --arg country "$country" \
            --argjson coi "$coi_json" \
            '{
              "username": $username,
              "enabled": true,
              "firstName": $first_name,
              "lastName": $last_name,
              "email": $email,
              "emailVerified": true,
              "requiredActions": [],
              "attributes": {
                "clearance": [$clearance],
                "countryOfAffiliation": [$country],
                "acpCOI": $coi
              }
            }')

          curl -sk -X POST "https://localhost:8443/admin/realms/$REALM/users" \
            -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
            -d "$user_payload" >/dev/null 2>&1 || true

          local user_id
          user_id=$(curl -sk "https://localhost:8443/admin/realms/$REALM/users?username=$username&exact=true" \
            -H "Authorization: Bearer $TOKEN" | jq -r '.[0].id // empty')
          if [ -z "$user_id" ]; then
            echo "::error::Failed to resolve Keycloak user id for $username"
            return 1
          fi

          local update_payload
          update_payload=$(echo "$user_payload" | jq -c --arg id "$user_id" '. + {"id": $id}')
          curl -sk -X PUT "https://localhost:8443/admin/realms/$REALM/users/$user_id" \
            -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
            -d "$update_payload" >/dev/null

          curl -sk -X PUT "https://localhost:8443/admin/realms/$REALM/users/$user_id/reset-password" \
            -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
            -d "{\"type\":\"password\",\"value\":\"$password\",\"temporary\":false}" >/dev/null

          local required_actions
          required_actions=$(curl -sk "https://localhost:8443/admin/realms/$REALM/users/$user_id" \
            -H "Authorization: Bearer $TOKEN" | jq -r '.requiredActions | join(",")')
          if [ -n "$required_actions" ]; then
            echo "::warning::User $username still has required actions: $required_actions"
          fi

          echo "::notice::Ensured user: $username ($clearance, $country)"
        }

        # Create users from JSON input (upsert + password reset for deterministic CI behavior)
        if ! echo '${{ inputs.keycloak-users }}' | jq -c '.[]' | while read -r user; do
          username=$(echo "$user" | jq -r '.username')
          password=$(echo "$user" | jq -r '.password')
          clearance=$(echo "$user" | jq -r '.clearance')
          coi=$(echo "$user" | jq -c '.coi // []')
          country=$(echo "$user" | jq -r '.countryOfAffiliation // "USA"')
          first_name=$(echo "$user" | jq -r '.firstName // "Test"')
          last_name=$(echo "$user" | jq -r '.lastName // "User"')
          email=$(echo "$user" | jq -r '.email // empty')
          if [ -z "$email" ]; then
            email="${username}@dive-ci.test"
          fi

          upsert_user "$username" "$password" "$clearance" "$coi" "$first_name" "$last_name" "$email" "$country" || exit 1
        done; then
          echo "::error::Failed to provision one or more Keycloak test users"
          exit 1
        fi

        # Ensure baseline AAL1 test user exists for Playwright auth state generation.
        upsert_user "testuser-usa-1" "TestUser2025!Pilot" "UNCLASSIFIED" "[]" "Test" "User" "testuser-usa-1@dive-ci.test" "USA"
        echo "::notice::Ensured baseline user: testuser-usa-1"

    - name: Setup PostgreSQL Schema
      shell: bash
      run: cd frontend && npx drizzle-kit push --force || true
      env:
        DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app

    - name: Cache Playwright Browsers
      uses: actions/cache@v4
      id: playwright-cache
      with:
        path: ~/.cache/ms-playwright
        key: playwright-${{ runner.os }}-${{ hashFiles('frontend/package-lock.json') }}

    - name: Install Playwright Browsers
      if: steps.playwright-cache.outputs.cache-hit != 'true'
      shell: bash
      run: cd frontend && npx playwright install chromium --with-deps

    - name: Install Playwright System Dependencies
      if: steps.playwright-cache.outputs.cache-hit == 'true'
      shell: bash
      run: cd frontend && npx playwright install-deps chromium

    - name: Start Backend HTTPS Server
      shell: bash
      run: |
        cd backend
        nohup npx tsx src/https-server.ts > backend.log 2>&1 &
        BACKEND_PID=$!
        echo "Backend PID: $BACKEND_PID"

        for i in {1..90}; do
          if curl -kfsS https://localhost:4000/api/health/live >/dev/null 2>&1; then
            echo "::notice::Backend HTTPS server ready"
            break
          fi

          if ! kill -0 "$BACKEND_PID" 2>/dev/null; then
            echo "::error::Backend process exited before becoming ready"
            tail -n 300 backend.log || true
            exit 1
          fi

          if [ $i -eq 90 ]; then
            echo "::error::Backend failed to become ready on https://localhost:4000"
            tail -n 300 backend.log || true
            exit 1
          fi
          sleep 2
        done
      env:
        NODE_ENV: test
        PORT: "4000"
        SSL_CERT_PATH: ${{ github.workspace }}/frontend/certs
        MONGODB_URL: mongodb://localhost:27017/dive-v3-test
        MONGODB_DATABASE: dive-v3-test
        DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
        KEYCLOAK_URL: https://localhost:8443
        KEYCLOAK_REALM: dive-v3-broker-usa
        NEXT_PUBLIC_KEYCLOAK_URL: https://localhost:8443
        NEXT_PUBLIC_KEYCLOAK_REALM: dive-v3-broker-usa
        KEYCLOAK_CLIENT_ID: dive-v3-broker-usa
        KEYCLOAK_CLIENT_SECRET: test-client-secret
        KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
        KEYCLOAK_ADMIN_USER: admin
        KEYCLOAK_ADMIN_PASSWORD: admin
        KC_ADMIN_PASSWORD: admin
        ALLOW_INSECURE_LOCAL_DEVELOPMENT: "true"

    - name: Start Next.js HTTPS Server
      shell: bash
      run: |
        cd frontend
        # Verify Node can reach Keycloak OIDC metadata before booting NextAuth.
        node -e "
          fetch('https://localhost:8443/realms/dive-v3-broker-usa/.well-known/openid-configuration')
            .then(async (response) => {
              if (!response.ok) {
                throw new Error('OIDC metadata request failed with status ' + response.status);
              }
              const metadata = await response.json();
              console.log('Keycloak OIDC metadata reachable:', metadata.issuer);
            })
            .catch((error) => {
              console.error('Failed to reach Keycloak OIDC metadata:', error);
              process.exit(1);
            });
        "

        npm run build
        nohup node server.js > nextjs.log 2>&1 &

        for i in {1..60}; do
          if curl -k -f https://localhost:3000 2>/dev/null; then
            echo "::notice::Next.js HTTPS server ready"
            break
          fi
          if [ $i -eq 60 ]; then
            echo "::error::Next.js failed to start"
            cat nextjs.log
            exit 1
          fi
          sleep 2
        done
      env:
        NODE_ENV: production
        NEXTAUTH_URL: https://localhost:3000
        NEXTAUTH_SECRET: ${{ inputs.nextauth-secret }}
        AUTH_URL: https://localhost:3000
        AUTH_SECRET: ${{ inputs.nextauth-secret }}
        AUTH_TRUST_HOST: "true"
        PORT: "3000"
        SSL_CERT_PATH: ${{ github.workspace }}/frontend/certs
        DATABASE_URL: postgresql://postgres:password@localhost:5432/dive_v3_app
        KEYCLOAK_URL: https://localhost:8443
        KEYCLOAK_REALM: dive-v3-broker-usa
        NEXT_PUBLIC_KEYCLOAK_URL: https://localhost:8443
        NEXT_PUBLIC_KEYCLOAK_REALM: dive-v3-broker-usa
        KEYCLOAK_CLIENT_ID: dive-v3-broker-usa
        KEYCLOAK_CLIENT_SECRET: test-client-secret
        KEYCLOAK_INSECURE_SKIP_VERIFY: "true"
        BACKEND_URL: https://localhost:4000
        NEXT_PUBLIC_API_URL: https://localhost:4000
        NODE_EXTRA_CA_CERTS: ${{ github.workspace }}/certs/ca-bundle.pem
        MONGODB_URL: mongodb://localhost:27017/dive-v3-test

    - name: Generate Playwright Auth State Files
      shell: bash
      run: |
        cd frontend
        if ! npx tsx -e "import setup from './src/__tests__/e2e/fixtures/auth-setup.ts'; (async () => { await setup({ projects: [{ use: { baseURL: process.env.BASE_URL || 'https://localhost:3000' } }] } as any); })().catch((error) => { console.error(error); process.exit(1); });"; then
          echo "::group::Next.js log tail"
          tail -n 300 nextjs.log || true
          echo "::endgroup::"
          echo "::group::Backend log tail"
          tail -n 300 ../backend/backend.log || true
          echo "::endgroup::"
          exit 1
        fi

        if [ ! -f .auth/aal1.json ]; then
          echo "::error::Missing required Playwright auth state: .auth/aal1.json"
          exit 1
        fi

        if [ ! -f .auth/admin.json ]; then
          echo "::warning::Admin auth state was not generated (.auth/admin.json)"
        fi
      env:
        BASE_URL: https://localhost:3000
        CI: "true"
        ENABLE_MFA_TESTS: "false"

    - name: Start OPA Server
      if: inputs.start-opa == 'true'
      shell: bash
      run: |
        curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64_static
        chmod +x opa
        nohup ./opa run --server --addr=:8181 --log-level=error \
          --tls-cert-file=${{ github.workspace }}/certs/certificate.pem \
          --tls-private-key-file=${{ github.workspace }}/certs/key.pem \
          > opa.log 2>&1 &
        sleep 5
        curl -k -f https://localhost:8181/health || (cat opa.log && exit 1)
        echo "::notice::OPA server ready"
