/**
 * COI Validation Service Tests
 * 
 * Comprehensive tests for COI coherence validation
 * Tests all invariants and edge cases
 * 
 * Date: October 21, 2025
 */

import {
    validateCOICoherence,
    getAllowedCOIs,
    getAllowedCountriesForCOIs,
    suggestCOIOperator
} from '../coi-validation.service';

describe.skip('COI Validation Service', () => {
    // ============================================
    // INVARIANT 1: Mutual Exclusivity
    // ============================================

    describe('Mutual Exclusivity', () => {
        test('US-ONLY cannot be combined with CAN-US', async () => {
            const result = await validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'CAN'],
                COI: ['US-ONLY', 'CAN-US'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('US-ONLY cannot be combined with foreign-sharing COIs')
            );
        });

        test('US-ONLY cannot be combined with FVEY', async () => {
            const result = await validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA'],
                COI: ['US-ONLY', 'FVEY'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('US-ONLY cannot be combined with foreign-sharing COIs')
            );
        });

        test('EU-RESTRICTED cannot be combined with NATO-COSMIC', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['FRA', 'DEU'],
                COI: ['EU-RESTRICTED', 'NATO-COSMIC'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('EU-RESTRICTED cannot be combined with NATO-COSMIC')
            );
        });

        test('EU-RESTRICTED cannot be combined with US-ONLY', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['FRA'],
                COI: ['EU-RESTRICTED', 'US-ONLY'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('EU-RESTRICTED cannot be combined with US-ONLY')
            );
        });
    });

    // ============================================
    // INVARIANT 2: Subset/Superset (ANY operator)
    // ============================================

    describe('Subset/Superset with ANY operator', () => {
        test('CAN-US + FVEY invalid with ANY operator', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'CAN'],
                COI: ['CAN-US', 'FVEY'],
                coiOperator: 'ANY'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('Subset+superset COIs [CAN-US, FVEY]')
            );
        });

        test('GBR-US + FVEY invalid with ANY operator', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'GBR'],
                COI: ['GBR-US', 'FVEY'],
                coiOperator: 'ANY'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('Subset+superset COIs [GBR-US, FVEY]')
            );
        });

        test('AUKUS + FVEY invalid with ANY operator', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['AUS', 'GBR', 'USA'],
                COI: ['AUKUS', 'FVEY'],
                coiOperator: 'ANY'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('Subset+superset COIs [AUKUS, FVEY]')
            );
        });

        test('NATO-COSMIC + NATO invalid with ANY operator', () => {
            const result = validateCOICoherence({
                classification: 'TOP_SECRET',
                releasabilityTo: ['USA', 'GBR', 'FRA'],
                COI: ['NATO-COSMIC', 'NATO'],
                coiOperator: 'ANY'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('Subset+superset COIs [NATO-COSMIC, NATO]')
            );
        });

        test('CAN-US + FVEY valid with ALL operator (no widening)', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'CAN'],
                COI: ['CAN-US', 'FVEY'],
                coiOperator: 'ALL'
            });

            // Should still fail because CAN not in FVEY releasability, but not due to operator
            expect(result.valid).toBe(false);
            expect(result.errors).not.toContainEqual(
                expect.stringContaining('Subset+superset')
            );
        });
    });

    // ============================================
    // INVARIANT 3: Releasability ⊆ COI Membership
    // ============================================

    describe('Releasability Alignment', () => {
        test('COI=CAN-US requires REL TO ⊆ {CAN, USA}', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'CAN', 'GBR'], // GBR not in CAN-US
                COI: ['CAN-US'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringMatching(/Releasability country GBR not in COI union/)
            );
        });

        test('COI=FVEY requires REL TO ⊆ {USA, GBR, CAN, AUS, NZL}', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'GBR', 'FRA'], // FRA not in FVEY
                COI: ['FVEY'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringMatching(/Releasability country FRA not in COI union/)
            );
        });

        test('COI=US-ONLY requires REL TO = {USA}', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'CAN'], // CAN not allowed
                COI: ['US-ONLY'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringMatching(/Releasability country CAN not in COI union/)
            );
        });

        test('Valid: COI=FVEY with REL TO ⊆ FVEY members', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'GBR', 'CAN'],
                COI: ['FVEY'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(true);
            expect(result.errors).toHaveLength(0);
        });
    });

    // ============================================
    // INVARIANT 4: Caveat Enforcement (NOFORN)
    // ============================================

    describe('NOFORN Caveat Enforcement', () => {
        test('NOFORN requires COI=[US-ONLY]', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA'],
                COI: ['CAN-US'],
                coiOperator: 'ALL',
                caveats: ['NOFORN']
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('NOFORN caveat requires COI=[US-ONLY]')
            );
        });

        test('NOFORN requires REL TO=[USA]', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'CAN'],
                COI: ['US-ONLY'],
                coiOperator: 'ALL',
                caveats: ['NOFORN']
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('NOFORN caveat requires releasabilityTo=[USA]')
            );
        });

        test('Valid: NOFORN with US-ONLY and REL USA', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA'],
                COI: ['US-ONLY'],
                coiOperator: 'ALL',
                caveats: ['NOFORN']
            });

            expect(result.valid).toBe(true);
            expect(result.errors).toHaveLength(0);
        });
    });

    // ============================================
    // INVARIANT 5: Empty Releasability
    // ============================================

    describe('Empty Releasability', () => {
        test('Empty releasabilityTo is invalid', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: [],
                COI: ['FVEY'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(false);
            expect(result.errors).toContainEqual(
                expect.stringContaining('Empty releasabilityTo')
            );
        });
    });

    // ============================================
    // Helper Functions
    // ============================================

    describe('getAllowedCOIs', () => {
        test('Returns all COIs when none selected', () => {
            const allowed = getAllowedCOIs([]);
            expect(allowed.length).toBeGreaterThan(10);
            expect(allowed).toContain('FVEY');
            expect(allowed).toContain('NATO');
        });

        test('Excludes foreign-sharing COIs when US-ONLY selected', () => {
            const allowed = getAllowedCOIs(['US-ONLY']);
            expect(allowed).not.toContain('CAN-US');
            expect(allowed).not.toContain('FVEY');
            expect(allowed).not.toContain('NATO');
        });

        test('Excludes US-ONLY when CAN-US selected', () => {
            const allowed = getAllowedCOIs(['CAN-US']);
            expect(allowed).not.toContain('US-ONLY');
        });

        test('Excludes NATO-COSMIC when EU-RESTRICTED selected', () => {
            const allowed = getAllowedCOIs(['EU-RESTRICTED']);
            expect(allowed).not.toContain('NATO-COSMIC');
            expect(allowed).not.toContain('US-ONLY');
        });
    });

    describe('getAllowedCountriesForCOIs', () => {
        test('Returns FVEY members for FVEY COI', () => {
            const countries = getAllowedCountriesForCOIs(['FVEY']);
            expect(countries).toContain('USA');
            expect(countries).toContain('GBR');
            expect(countries).toContain('CAN');
            expect(countries).toContain('AUS');
            expect(countries).toContain('NZL');
            expect(countries).not.toContain('FRA');
        });

        test('Returns USA for US-ONLY COI', () => {
            const countries = getAllowedCountriesForCOIs(['US-ONLY']);
            expect(countries).toEqual(['USA']);
        });

        test('Returns union for multiple COIs', () => {
            const countries = getAllowedCountriesForCOIs(['CAN-US', 'GBR-US']);
            expect(countries).toContain('USA');
            expect(countries).toContain('CAN');
            expect(countries).toContain('GBR');
            expect(countries.length).toBe(3);
        });

        test('Returns empty for no COIs', () => {
            const countries = getAllowedCountriesForCOIs([]);
            expect(countries).toEqual([]);
        });
    });

    describe('suggestCOIOperator', () => {
        test('Suggests ALL for no COIs', () => {
            const { operator, reason } = suggestCOIOperator([]);
            expect(operator).toBe('ALL');
            expect(reason).toContain('no COIs selected');
        });

        test('Suggests ALL for single COI', () => {
            const { operator, reason } = suggestCOIOperator(['FVEY']);
            expect(operator).toBe('ALL');
            expect(reason).toContain('Single COI');
        });

        test('Suggests ALL for subset+superset pairs', () => {
            const { operator, reason } = suggestCOIOperator(['CAN-US', 'FVEY']);
            expect(operator).toBe('ALL');
            expect(reason).toContain('subset+superset');
            expect(reason).toContain('prevent widening');
        });

        test('Suggests ALL (safer) for multiple independent COIs', () => {
            const { operator, reason } = suggestCOIOperator(['NATO', 'QUAD']);
            expect(operator).toBe('ALL');
            expect(reason).toContain('Recommended');
        });
    });

    // ============================================
    // Complex Scenarios
    // ============================================

    describe('Complex Valid Scenarios', () => {
        test('Valid: NATO with subset of NATO countries', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'GBR', 'FRA', 'DEU'],
                COI: ['NATO'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(true);
        });

        test('Valid: AUKUS with all AUKUS members', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['AUS', 'GBR', 'USA'],
                COI: ['AUKUS'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(true);
        });

        test('Valid: Multiple COIs with ALL operator (intersection)', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'GBR', 'CAN'],
                COI: ['FVEY', 'NATO'],
                coiOperator: 'ALL'
            });

            expect(result.valid).toBe(true);
        });
    });

    describe('Complex Invalid Scenarios', () => {
        test('Invalid: Multiple violations at once', () => {
            const result = validateCOICoherence({
                classification: 'SECRET',
                releasabilityTo: ['USA', 'FRA', 'KOR'], // KOR not in US-ONLY
                COI: ['US-ONLY', 'FVEY'], // Mutual exclusivity violation
                coiOperator: 'ANY', // Subset+superset violation
                caveats: ['NOFORN'] // Caveat violation
            });

            expect(result.valid).toBe(false);
            expect(result.errors.length).toBeGreaterThan(2);
        });

        test('Invalid: Nonsensical combo from audit example', () => {
            const result = validateCOICoherence({
                classification: 'CONFIDENTIAL',
                releasabilityTo: ['NOR', 'SVN', 'EST', 'KOR'],
                COI: ['CAN-US', 'US-ONLY', 'EU-RESTRICTED'],
                coiOperator: 'ANY'
            });

            expect(result.valid).toBe(false);
            // Should have multiple violations
            expect(result.errors.length).toBeGreaterThan(3);
        });
    });
});

