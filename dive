#!/bin/bash
# =============================================================================
# DIVE V3 CLI - Unified Management Script
# =============================================================================
# Usage:
#   ./dive [options] [command] [subcommand] [args...]
#
# Global Options:
#   --env local|gcp|pilot    Set environment (default: local)
#   --instance usa|fra|deu   Set instance (default: usa)
#   --dry-run                Show what would be done without executing
#   --verbose                Show detailed output
#   --quiet                  Suppress non-essential output
#
# Examples:
#   ./dive up                      # Start locally with defaults
#   ./dive --dry-run deploy        # Preview full deployment
#   ./dive --env gcp up            # Start with GCP secrets
#   ./dive pilot up                # Start on remote pilot VM
# =============================================================================

set -e

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m'

# Defaults
ENVIRONMENT="${DIVE_ENV:-local}"
INSTANCE="${DIVE_INSTANCE:-usa}"
GCP_PROJECT="${GCP_PROJECT:-dive25}"
PILOT_VM="dive-v3-pilot"
PILOT_ZONE="us-east4-c"
DRY_RUN=false
VERBOSE=false
QUIET=false

# Project root
DIVE_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$DIVE_ROOT"

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

upper() {
    echo "$1" | tr '[:lower:]' '[:upper:]'
}

log_info() {
    [ "$QUIET" = true ] && return
    echo -e "${BLUE}ℹ ${NC}$1"
}

log_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

log_warn() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
    echo -e "${RED}❌ $1${NC}"
}

log_step() {
    [ "$QUIET" = true ] && return
    echo -e "${CYAN}→ $1${NC}"
}

log_dry() {
    echo -e "${GRAY}[DRY-RUN] $1${NC}"
}

log_verbose() {
    [ "$VERBOSE" = true ] && echo -e "${GRAY}  $1${NC}"
}

# Execute command (or log if dry-run)
run() {
    if [ "$DRY_RUN" = true ]; then
        log_dry "$*"
        return 0
    fi
    [ "$VERBOSE" = true ] && log_verbose "Executing: $*"
    "$@"
}

# Execute docker compose
dc() {
    local compose_file="${COMPOSE_FILE:-docker-compose.yml}"
    if [ "$DRY_RUN" = true ]; then
        log_dry "docker compose -f $compose_file $*"
        return 0
    fi
    docker compose -f "$compose_file" "$@"
}

print_header() {
    [ "$QUIET" = true ] && return
    local env_upper=$(upper "$ENVIRONMENT")
    local inst_upper=$(upper "$INSTANCE")
    local dry_flag=""
    [ "$DRY_RUN" = true ] && dry_flag=" [DRY-RUN]"
    echo -e "${CYAN}"
    echo "╔════════════════════════════════════════════════════════════════════════╗"
    echo "║                         DIVE V3 CLI                                    ║"
    printf "║          Environment: %-6s | Instance: %-4s%-12s       ║\n" "$env_upper" "$inst_upper" "$dry_flag"
    echo "╚════════════════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

check_docker() {
    if ! docker info > /dev/null 2>&1; then
        log_error "Docker is not running."
        return 1
    fi
    log_verbose "Docker is running"
    return 0
}

check_gcloud() {
    if ! command -v gcloud &> /dev/null; then
        log_error "gcloud CLI not installed"
        return 1
    fi
    if ! gcloud auth list --filter=status:ACTIVE --format="value(account)" 2>/dev/null | grep -q "@"; then
        log_error "Not authenticated to GCP. Run: gcloud auth login"
        return 1
    fi
    log_verbose "gcloud is authenticated"
    return 0
}

check_terraform() {
    if ! command -v terraform &> /dev/null; then
        log_error "Terraform not installed"
        return 1
    fi
    log_verbose "Terraform is installed: $(terraform version -json 2>/dev/null | jq -r '.terraform_version' || terraform version | head -1)"
    return 0
}

check_certs() {
    if [ ! -f "keycloak/certs/certificate.pem" ] || [ ! -f "keycloak/certs/key.pem" ]; then
        log_warn "SSL Certificates missing"
        if [ "$DRY_RUN" = true ]; then
            log_dry "Would generate certificates via ./scripts/generate-dev-certs.sh"
            return 0
        fi
        if [ -x "./scripts/generate-dev-certs.sh" ]; then
            ./scripts/generate-dev-certs.sh
        else
            log_error "scripts/generate-dev-certs.sh not found"
            return 1
        fi
    fi
    log_verbose "SSL certificates present"
    return 0
}

cmd_validate() {
        print_header
    echo -e "${BOLD}Validating DIVE V3 Configuration...${NC}"
    echo ""
    
    local errors=0
    
    # Docker
    echo -n "  Docker:        "
    if check_docker 2>/dev/null; then
        echo -e "${GREEN}✓${NC}"
    else
        echo -e "${RED}✗${NC}"
        ((errors++))
    fi
    
    # gcloud
    echo -n "  GCP (gcloud):  "
    if check_gcloud 2>/dev/null; then
        echo -e "${GREEN}✓${NC}"
    else
        echo -e "${RED}✗${NC}"
        ((errors++))
    fi
    
    # Terraform
    echo -n "  Terraform:     "
    if check_terraform 2>/dev/null; then
        echo -e "${GREEN}✓${NC}"
    else
        echo -e "${RED}✗${NC}"
        ((errors++))
    fi
    
    # SSL Certs
    echo -n "  SSL Certs:     "
    if [ -f "keycloak/certs/certificate.pem" ]; then
        echo -e "${GREEN}✓${NC}"
    else
        echo -e "${YELLOW}missing (will generate)${NC}"
    fi
    
    # Compose files
    echo -n "  Compose files: "
    local compose_count=0
    [ -f "docker-compose.yml" ] && ((compose_count++))
    [ -f "docker-compose.pilot.yml" ] && ((compose_count++))
    [ -f "docker-compose.dev.yml" ] && ((compose_count++))
    echo -e "${GREEN}${compose_count} found${NC}"
    
    # Terraform configs
    echo -n "  TF configs:    "
    local tf_count=$(find terraform -name "*.tf" 2>/dev/null | wc -l | tr -d ' ')
    echo -e "${GREEN}${tf_count} files${NC}"
    
    # GCP Secrets
    echo -n "  GCP Secrets:   "
    if check_gcloud 2>/dev/null; then
        local secret_count=$(gcloud secrets list --project="$GCP_PROJECT" --filter="name:dive-v3" --format="value(name)" 2>/dev/null | wc -l | tr -d ' ')
        echo -e "${GREEN}${secret_count} configured${NC}"
    else
        echo -e "${YELLOW}unable to check${NC}"
    fi
    
    echo ""
    if [ $errors -eq 0 ]; then
        log_success "All validations passed!"
        return 0
    else
        log_error "$errors validation(s) failed"
        return 1
    fi
}

# =============================================================================
# GCP SECRETS MANAGEMENT
# =============================================================================

load_gcp_secrets() {
    local instance="${1:-usa}"
    
    log_step "Loading secrets from GCP Secret Manager ($(upper "$instance"))..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "Would fetch: dive-v3-postgres-${instance}"
        log_dry "Would fetch: dive-v3-keycloak-${instance}"
        log_dry "Would fetch: dive-v3-mongodb-${instance}"
        log_dry "Would fetch: dive-v3-auth-secret-${instance}"
        log_dry "Would fetch: dive-v3-keycloak-client-secret-${instance}"
        export POSTGRES_PASSWORD="<gcp-secret>"
        export KEYCLOAK_ADMIN_PASSWORD="<gcp-secret>"
        export MONGO_PASSWORD="<gcp-secret>"
        export AUTH_SECRET="<gcp-secret>"
        export KEYCLOAK_CLIENT_SECRET="<gcp-secret>"
        return 0
    fi
    
    check_gcloud || return 1
    
    # Fetch secrets
    export POSTGRES_PASSWORD=$(gcloud secrets versions access latest --secret="dive-v3-postgres-${instance}" --project="$GCP_PROJECT" 2>/dev/null || echo "")
    export KEYCLOAK_ADMIN_PASSWORD=$(gcloud secrets versions access latest --secret="dive-v3-keycloak-${instance}" --project="$GCP_PROJECT" 2>/dev/null || echo "")
    export MONGO_PASSWORD=$(gcloud secrets versions access latest --secret="dive-v3-mongodb-${instance}" --project="$GCP_PROJECT" 2>/dev/null || echo "")
    export AUTH_SECRET=$(gcloud secrets versions access latest --secret="dive-v3-auth-secret-${instance}" --project="$GCP_PROJECT" 2>/dev/null || echo "")
    export KEYCLOAK_CLIENT_SECRET=$(gcloud secrets versions access latest --secret="dive-v3-keycloak-client-secret-${instance}" --project="$GCP_PROJECT" 2>/dev/null || echo "")
    
    # Also set JWT and NextAuth secrets
    export JWT_SECRET=$(gcloud secrets versions access latest --secret="dive-v3-jwt-secret-${instance}" --project="$GCP_PROJECT" 2>/dev/null || echo "")
    export NEXTAUTH_SECRET=$(gcloud secrets versions access latest --secret="dive-v3-nextauth-secret-${instance}" --project="$GCP_PROJECT" 2>/dev/null || echo "")
    
    # Terraform variables
    export TF_VAR_keycloak_admin_password="$KEYCLOAK_ADMIN_PASSWORD"
    export TF_VAR_client_secret="$KEYCLOAK_CLIENT_SECRET"
    
    # Verify critical secrets
    local missing=0
    [ -z "$POSTGRES_PASSWORD" ] && log_warn "Missing: POSTGRES_PASSWORD" && ((missing++))
    [ -z "$KEYCLOAK_ADMIN_PASSWORD" ] && log_warn "Missing: KEYCLOAK_ADMIN_PASSWORD" && ((missing++))
    [ -z "$MONGO_PASSWORD" ] && log_warn "Missing: MONGO_PASSWORD" && ((missing++))
    
    if [ $missing -gt 0 ]; then
        log_error "Failed to load $missing critical secret(s)"
        return 1
    fi
    
    log_success "Secrets loaded from GCP"
    return 0
}

load_local_defaults() {
    log_warn "Using local development defaults (NOT for production!)"
        export POSTGRES_PASSWORD="${POSTGRES_PASSWORD:-DivePilot2025!}"
        export KEYCLOAK_ADMIN_PASSWORD="${KEYCLOAK_ADMIN_PASSWORD:-DivePilot2025!SecureAdmin}"
    export MONGO_PASSWORD="${MONGO_PASSWORD:-DivePilot2025!}"
    export AUTH_SECRET="${AUTH_SECRET:-local-dev-secret-not-for-production}"
    export KEYCLOAK_CLIENT_SECRET="${KEYCLOAK_CLIENT_SECRET:-dive-v3-client-secret}"
    export JWT_SECRET="${JWT_SECRET:-local-jwt-secret}"
    export NEXTAUTH_SECRET="${NEXTAUTH_SECRET:-local-nextauth-secret}"
    export TF_VAR_keycloak_admin_password="$KEYCLOAK_ADMIN_PASSWORD"
    export TF_VAR_client_secret="$KEYCLOAK_CLIENT_SECRET"
}

load_secrets() {
    case "$ENVIRONMENT" in
        local|dev)
            load_local_defaults
            ;;
        gcp|pilot|prod|staging)
            load_gcp_secrets "$INSTANCE"
            ;;
        *)
            log_error "Unknown environment: $ENVIRONMENT"
            return 1
            ;;
    esac
}

cmd_secrets() {
    local action="${1:-show}"
    local instance="${2:-$INSTANCE}"
    
    case "$action" in
        load)
            load_gcp_secrets "$instance"
            log_success "Secrets loaded into environment"
            ;;
        show)
            echo -e "${CYAN}Secrets for $(upper "$instance"):${NC}"
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would query: gcloud secrets list --project=$GCP_PROJECT"
            else
                gcloud secrets list --project="$GCP_PROJECT" --filter="name:dive-v3" --format="table(name,createTime)" | grep -i "$instance" || echo "No instance-specific secrets found"
            fi
            ;;
        list)
            echo -e "${CYAN}All DIVE V3 secrets in GCP:${NC}"
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would query: gcloud secrets list --project=$GCP_PROJECT"
            else
                gcloud secrets list --project="$GCP_PROJECT" --filter="name:dive-v3" --format="table(name,createTime)"
            fi
            ;;
        verify)
            echo -e "${CYAN}Verifying secrets can be accessed...${NC}"
            load_gcp_secrets "$instance"
            echo ""
            echo -e "  POSTGRES_PASSWORD:        $([ -n "$POSTGRES_PASSWORD" ] && echo -e "${GREEN}✓ loaded${NC}" || echo -e "${RED}✗ missing${NC}")"
            echo -e "  KEYCLOAK_ADMIN_PASSWORD:  $([ -n "$KEYCLOAK_ADMIN_PASSWORD" ] && echo -e "${GREEN}✓ loaded${NC}" || echo -e "${RED}✗ missing${NC}")"
            echo -e "  MONGO_PASSWORD:           $([ -n "$MONGO_PASSWORD" ] && echo -e "${GREEN}✓ loaded${NC}" || echo -e "${RED}✗ missing${NC}")"
            echo -e "  AUTH_SECRET:              $([ -n "$AUTH_SECRET" ] && echo -e "${GREEN}✓ loaded${NC}" || echo -e "${RED}✗ missing${NC}")"
            echo -e "  KEYCLOAK_CLIENT_SECRET:   $([ -n "$KEYCLOAK_CLIENT_SECRET" ] && echo -e "${GREEN}✓ loaded${NC}" || echo -e "${RED}✗ missing${NC}")"
            echo -e "  JWT_SECRET:               $([ -n "$JWT_SECRET" ] && echo -e "${GREEN}✓ loaded${NC}" || echo -e "${RED}✗ missing${NC}")"
            echo -e "  NEXTAUTH_SECRET:          $([ -n "$NEXTAUTH_SECRET" ] && echo -e "${GREEN}✓ loaded${NC}" || echo -e "${RED}✗ missing${NC}")"
            ;;
        export)
            # Export secrets as env vars to stdout (for piping)
            load_gcp_secrets "$instance" >/dev/null 2>&1
            echo "export POSTGRES_PASSWORD='$POSTGRES_PASSWORD'"
            echo "export KEYCLOAK_ADMIN_PASSWORD='$KEYCLOAK_ADMIN_PASSWORD'"
            echo "export MONGO_PASSWORD='$MONGO_PASSWORD'"
            echo "export AUTH_SECRET='$AUTH_SECRET'"
            echo "export KEYCLOAK_CLIENT_SECRET='$KEYCLOAK_CLIENT_SECRET'"
            echo "export JWT_SECRET='$JWT_SECRET'"
            echo "export NEXTAUTH_SECRET='$NEXTAUTH_SECRET'"
            echo "export TF_VAR_keycloak_admin_password='$KEYCLOAK_ADMIN_PASSWORD'"
            echo "export TF_VAR_client_secret='$KEYCLOAK_CLIENT_SECRET'"
            ;;
        *)
            echo "Usage: ./dive secrets [load|show|list|verify|export] [instance]"
            ;;
    esac
}

# =============================================================================
# CORE COMMANDS
# =============================================================================

cmd_up() {
        print_header
    check_docker || exit 1
    check_certs || exit 1
    load_secrets
    
    log_step "Starting DIVE V3 Stack..."
    
    # Choose compose file based on environment
    COMPOSE_FILE="docker-compose.yml"
    [ "$ENVIRONMENT" = "pilot" ] && COMPOSE_FILE="docker-compose.pilot.yml"
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "docker compose -f $COMPOSE_FILE up -d"
    else
        dc up -d
    fi
    
    log_success "Stack started"
        echo ""
    echo "  Frontend: https://localhost:3000"
    echo "  Backend:  https://localhost:4000"
    echo "  Keycloak: https://localhost:8443"
}

cmd_down() {
    log_step "Stopping containers..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "docker compose -f docker-compose.yml down"
        log_dry "docker compose -f docker-compose.pilot.yml down"
    else
        docker compose -f docker-compose.yml down 2>/dev/null || true
        docker compose -f docker-compose.pilot.yml down 2>/dev/null || true
    fi
    
    log_success "Stack stopped"
}

cmd_restart() {
    local service="${1:-}"
    
    if [ -n "$service" ]; then
        log_step "Restarting $service..."
        run docker compose restart "$service"
    else
        cmd_down
        sleep 2
        cmd_up
    fi
}

cmd_logs() {
    local service="${1:-}"
    local lines="${2:-100}"
    
    if [ -n "$service" ]; then
        docker compose logs -f --tail="$lines" "$service"
    else
        docker compose logs -f --tail="$lines"
    fi
}

cmd_ps() {
    echo -e "${CYAN}Running DIVE Containers:${NC}"
    docker ps --filter "name=dive" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || echo "No containers running"
}

cmd_exec() {
    local container="$1"
    shift
    local cmd="${@:-bash}"
    
    if [ -z "$container" ]; then
        echo "Usage: ./dive exec <container> [command]"
        echo "Containers: frontend, backend, keycloak, postgres, mongo, redis, opa"
        return 1
    fi
    
    # Map short names to container names
    case "$container" in
        fe|frontend) container="dive-pilot-frontend" ;;
        be|backend)  container="dive-pilot-backend" ;;
        kc|keycloak) container="dive-pilot-keycloak" ;;
        pg|postgres) container="dive-pilot-postgres" ;;
        mongo|mongodb) container="dive-pilot-mongo" ;;
        redis)       container="dive-pilot-redis" ;;
        opa)         container="dive-pilot-opa" ;;
    esac
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "docker exec -it $container $cmd"
    else
        docker exec -it "$container" $cmd
    fi
}

# =============================================================================
# STATUS & HEALTH
# =============================================================================

cmd_status() {
    print_header
    
    echo -e "${BOLD}Local Containers:${NC}"
    docker ps --filter "name=dive" --format "  {{.Names}}: {{.Status}}" 2>/dev/null | head -15 || echo "  No containers running"
    
        echo ""
    echo -e "${BOLD}Remote Endpoints:${NC}"
    for endpoint in "usa-app.dive25.com" "usa-api.dive25.com" "usa-idp.dive25.com"; do
        local code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "https://$endpoint" 2>/dev/null || echo "000")
        if [ "$code" = "200" ] || [ "$code" = "302" ]; then
            echo -e "  ${GREEN}●${NC} $endpoint (${code})"
        else
            echo -e "  ${RED}○${NC} $endpoint (${code})"
        fi
    done
    
        echo ""
    echo -e "${BOLD}Environment:${NC}"
    echo "  Mode:     $ENVIRONMENT"
    echo "  Instance: $INSTANCE"
    echo "  Project:  $GCP_PROJECT"
}

cmd_health() {
    print_header
    echo -e "${BOLD}Service Health Checks:${NC}"
        echo ""
        
    local services=("frontend:3000" "backend:4000" "keycloak:8443" "postgres:5432" "mongo:27017" "redis:6379" "opa:8181")
    
    for svc in "${services[@]}"; do
        local name="${svc%%:*}"
        local port="${svc##*:}"
        local container="dive-pilot-${name}"
        
        echo -n "  $name: "
        
        if [ "$DRY_RUN" = true ]; then
            echo -e "${GRAY}[dry-run]${NC}"
            continue
        fi
        
        # Check if container exists
        if ! docker ps --format "{{.Names}}" | grep -q "$container"; then
            echo -e "${RED}not running${NC}"
            continue
        fi
        
        # Service-specific health checks
        case "$name" in
            frontend)
                if curl -kfs --max-time 3 "https://localhost:$port" >/dev/null 2>&1; then
                    echo -e "${GREEN}healthy${NC}"
                else
                    echo -e "${YELLOW}starting...${NC}"
                fi
                ;;
            backend)
                if curl -kfs --max-time 3 "https://localhost:$port/health" >/dev/null 2>&1; then
                    echo -e "${GREEN}healthy${NC}"
                else
                    echo -e "${YELLOW}starting...${NC}"
                fi
                ;;
            keycloak)
                if curl -kfs --max-time 3 "https://localhost:$port/health" >/dev/null 2>&1; then
                    echo -e "${GREEN}healthy${NC}"
                else
                    echo -e "${YELLOW}starting...${NC}"
                fi
                ;;
            postgres)
                if docker exec "$container" pg_isready -U postgres >/dev/null 2>&1; then
                    echo -e "${GREEN}healthy${NC}"
                else
                    echo -e "${YELLOW}starting...${NC}"
                fi
                ;;
            mongo)
                if docker exec "$container" mongosh --eval "db.runCommand('ping')" >/dev/null 2>&1; then
                    echo -e "${GREEN}healthy${NC}"
                else
                    echo -e "${YELLOW}starting...${NC}"
                fi
                ;;
            redis)
                if docker exec "$container" redis-cli ping >/dev/null 2>&1; then
                    echo -e "${GREEN}healthy${NC}"
                else
                    echo -e "${YELLOW}starting...${NC}"
                fi
                ;;
            opa)
                if curl -fs --max-time 3 "http://localhost:$port/health" >/dev/null 2>&1; then
                    echo -e "${GREEN}healthy${NC}"
                else
                    echo -e "${YELLOW}starting...${NC}"
                fi
                ;;
            *)
                echo -e "${GRAY}unknown${NC}"
                ;;
        esac
    done
}

# =============================================================================
# DEPLOY COMMAND (FULL WORKFLOW)
# =============================================================================

cmd_deploy() {
    local target="${1:-local}"
    
    print_header
    echo -e "${BOLD}Full Deployment Workflow${NC}"
    echo -e "Target: ${CYAN}$target${NC}"
    echo ""
    
    local steps=(
        "1. Validate prerequisites"
        "2. Load secrets"
        "3. Generate SSL certificates (if needed)"
        "4. Stop existing containers"
        "5. Remove old volumes (clean deploy)"
        "6. Start infrastructure services"
        "7. Wait for services to be healthy"
        "8. Apply Terraform configuration"
        "9. Seed database"
        "10. Verify deployment"
    )
    
    # Show plan
    echo -e "${BOLD}Deployment Steps:${NC}"
    for step in "${steps[@]}"; do
        echo "  $step"
    done
    echo ""
    
    if [ "$DRY_RUN" = true ]; then
        echo -e "${YELLOW}DRY-RUN MODE - No changes will be made${NC}"
        echo ""
        
        log_dry "Step 1: cmd_validate"
        log_dry "Step 2: load_secrets (env=$ENVIRONMENT, instance=$INSTANCE)"
        log_dry "Step 3: check_certs"
        log_dry "Step 4: docker compose down -v"
        log_dry "Step 5: docker volume rm postgres_data mongo_data redis_data"
        log_dry "Step 6: docker compose up -d"
        log_dry "Step 7: wait 60s + health checks"
        log_dry "Step 8: terraform apply -var-file=$INSTANCE.tfvars"
        log_dry "Step 9: npm run seed:$INSTANCE"
        log_dry "Step 10: curl health endpoints"
        return 0
    fi
    
    # Execute deployment
    log_step "Step 1: Validating prerequisites..."
    cmd_validate || { log_error "Validation failed"; return 1; }
    
    log_step "Step 2: Loading secrets..."
    load_secrets || { log_error "Failed to load secrets"; return 1; }
    
    log_step "Step 3: Checking SSL certificates..."
    check_certs || { log_error "Certificate generation failed"; return 1; }
    
    log_step "Step 4: Stopping existing containers..."
    docker compose -f docker-compose.yml down -v 2>/dev/null || true
    docker compose -f docker-compose.pilot.yml down -v 2>/dev/null || true
    
    log_step "Step 5: Removing old volumes..."
    docker volume rm dive-v3_postgres_data dive-v3_mongo_data dive-v3_redis_data 2>/dev/null || true
    
    log_step "Step 6: Starting infrastructure services..."
    docker compose -f docker-compose.yml up -d
    
    log_step "Step 7: Waiting for services (90s)..."
    local wait_time=0
    while [ $wait_time -lt 90 ]; do
        sleep 10
        wait_time=$((wait_time + 10))
        echo "  ${wait_time}s elapsed..."
        
        # Check if Keycloak is ready
        if curl -kfs --max-time 3 "https://localhost:8443/health" >/dev/null 2>&1; then
            log_success "Keycloak is healthy!"
                break
            fi
        done
        
    log_step "Step 8: Applying Terraform configuration..."
        cd terraform/pilot
    [ ! -d ".terraform" ] && terraform init
    terraform apply -var-file="${INSTANCE}.tfvars" -auto-approve
        cd ../..
    
    log_step "Step 9: Seeding database..."
    cmd_seed "$INSTANCE" || log_warn "Seeding may have issues (check logs)"
    
    log_step "Step 10: Verifying deployment..."
    cmd_health
    
        echo ""
    log_success "Deployment complete!"
        echo ""
    echo "  Frontend: https://localhost:3000"
    echo "  Backend:  https://localhost:4000"
    echo "  Keycloak: https://localhost:8443"
}

# =============================================================================
# DATABASE COMMANDS
# =============================================================================

cmd_seed() {
    local instance="${1:-$INSTANCE}"
    
    log_step "Seeding database for $(upper "$instance")..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "docker exec dive-pilot-backend npm run seed:$instance"
        return 0
    fi
    
    docker exec dive-pilot-backend npm run seed 2>/dev/null || {
        log_warn "npm run seed failed, trying alternative..."
        docker exec dive-pilot-backend node dist/scripts/seed-resources.js 2>/dev/null || {
            log_error "Seeding failed"
            return 1
        }
    }
    
    log_success "Database seeded"
}

cmd_backup() {
    local backup_dir="backups/$(date +%Y%m%d_%H%M%S)"
    
    log_step "Creating backup in $backup_dir..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "mkdir -p $backup_dir"
        log_dry "docker exec dive-pilot-postgres pg_dumpall -U postgres > $backup_dir/postgres.sql"
        log_dry "docker exec dive-pilot-mongo mongodump --archive > $backup_dir/mongo.archive"
        return 0
    fi
    
    mkdir -p "$backup_dir"
    
    # PostgreSQL
    log_info "Backing up PostgreSQL..."
    docker exec dive-pilot-postgres pg_dumpall -U postgres > "$backup_dir/postgres.sql" 2>/dev/null || log_warn "PostgreSQL backup failed"
    
    # MongoDB
    log_info "Backing up MongoDB..."
    docker exec dive-pilot-mongo mongodump --archive="$backup_dir/mongo.archive" 2>/dev/null || log_warn "MongoDB backup failed"
    
    log_success "Backup created: $backup_dir"
    ls -la "$backup_dir"
}

cmd_restore() {
    local backup_dir="$1"
    
    if [ -z "$backup_dir" ]; then
        echo "Usage: ./dive restore <backup-dir>"
        echo ""
        echo "Available backups:"
        ls -la backups/ 2>/dev/null | tail -10
        return 1
    fi
    
    if [ ! -d "$backup_dir" ]; then
        log_error "Backup directory not found: $backup_dir"
        return 1
    fi
    
    log_step "Restoring from $backup_dir..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "docker exec -i dive-pilot-postgres psql -U postgres < $backup_dir/postgres.sql"
        log_dry "docker exec dive-pilot-mongo mongorestore --archive=$backup_dir/mongo.archive"
        return 0
    fi
    
    # PostgreSQL
    if [ -f "$backup_dir/postgres.sql" ]; then
        log_info "Restoring PostgreSQL..."
        docker exec -i dive-pilot-postgres psql -U postgres < "$backup_dir/postgres.sql" 2>/dev/null || log_warn "PostgreSQL restore failed"
    fi
    
    # MongoDB
    if [ -f "$backup_dir/mongo.archive" ]; then
        log_info "Restoring MongoDB..."
        docker exec dive-pilot-mongo mongorestore --archive="$backup_dir/mongo.archive" --drop 2>/dev/null || log_warn "MongoDB restore failed"
    fi
    
    log_success "Restore complete"
}

# =============================================================================
# TERRAFORM COMMANDS
# =============================================================================

cmd_terraform() {
    local action="${1:-plan}"
    local tf_dir="${2:-pilot}"
    
    log_step "Running Terraform $action ($tf_dir)..."
    
    load_secrets
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "cd terraform/$tf_dir"
        log_dry "terraform init (if needed)"
        log_dry "terraform $action -var-file=$INSTANCE.tfvars"
        return 0
    fi
    
    cd "terraform/${tf_dir}"
    
        if [ ! -d ".terraform" ]; then
        log_info "Initializing Terraform..."
            terraform init
        fi
        
    case "$action" in
        plan)
            terraform plan -var-file="${INSTANCE}.tfvars"
            ;;
        apply)
            terraform apply -var-file="${INSTANCE}.tfvars" -auto-approve
            ;;
        destroy)
            terraform destroy -var-file="${INSTANCE}.tfvars" -auto-approve
            ;;
        output)
            terraform output
            ;;
        *)
            echo "Usage: ./dive tf [plan|apply|destroy|output] [dir]"
            return 1
            ;;
    esac
}

# =============================================================================
# RESET / NUKE COMMANDS
# =============================================================================

cmd_reset() {
    print_header
    echo -e "${RED}⚠️  RESETTING TO CLEAN STATE...${NC}"
    echo ""
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "Step 1: docker compose down -v --remove-orphans"
        log_dry "Step 2: check_certs"
        log_dry "Step 3: load_secrets"
        log_dry "Step 4: docker compose up -d"
        log_dry "Step 5: sleep 60 && terraform apply"
        return 0
    fi
    
    # Full deployment workflow
    cmd_deploy local
}

cmd_nuke() {
    log_warn "NUKING EVERYTHING (containers + volumes + networks)..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "docker compose -f docker-compose.yml down -v --remove-orphans"
        log_dry "docker compose -f docker-compose.pilot.yml down -v --remove-orphans"
        log_dry "docker volume prune -f"
        return 0
    fi
    
    docker compose -f docker-compose.yml down -v --remove-orphans 2>/dev/null || true
    docker compose -f docker-compose.pilot.yml down -v --remove-orphans 2>/dev/null || true
    docker volume prune -f 2>/dev/null || true
    
    log_success "Clean slate achieved"
}

# =============================================================================
# PILOT VM COMMANDS
# =============================================================================

pilot_cmd() {
    local cmd="$1"
    shift
    
    log_step "Executing on pilot VM ($PILOT_VM)..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "gcloud compute ssh $PILOT_VM --zone=$PILOT_ZONE --project=$GCP_PROJECT --command=\"$cmd\""
        return 0
    fi
    
    gcloud compute ssh "$PILOT_VM" --zone="$PILOT_ZONE" --project="$GCP_PROJECT" --command="$cmd" "$@"
}

pilot_up() {
    log_step "Starting services on pilot VM..."
    
    load_gcp_secrets "$INSTANCE"
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "Would create .env with secrets on VM"
        log_dry "Would run: docker compose -f docker-compose.pilot.yml up -d"
        return 0
    fi
    
    # Create env file and start
    local env_content="POSTGRES_PASSWORD=$POSTGRES_PASSWORD
KEYCLOAK_ADMIN_PASSWORD=$KEYCLOAK_ADMIN_PASSWORD
MONGO_PASSWORD=$MONGO_PASSWORD
AUTH_SECRET=$AUTH_SECRET
KEYCLOAK_CLIENT_SECRET=$KEYCLOAK_CLIENT_SECRET
JWT_SECRET=$JWT_SECRET
NEXTAUTH_SECRET=$NEXTAUTH_SECRET"
    
    echo "$env_content" | gcloud compute ssh "$PILOT_VM" --zone="$PILOT_ZONE" --project="$GCP_PROJECT" --command="
cat > /opt/dive-v3/.env
cd /opt/dive-v3
sudo docker compose --env-file .env -f docker-compose.pilot.yml up -d
echo ''
echo 'Service status:'
sudo docker compose -f docker-compose.pilot.yml ps
"
    
    log_success "Pilot VM services started"
    echo "  Frontend: https://usa-app.dive25.com"
    echo "  Keycloak: https://usa-idp.dive25.com"
}

pilot_down() {
    pilot_cmd "cd /opt/dive-v3 && sudo docker compose -f docker-compose.pilot.yml down"
}

pilot_status() {
    pilot_cmd "cd /opt/dive-v3 && sudo docker compose -f docker-compose.pilot.yml ps && echo '' && sudo docker compose -f docker-compose.pilot.yml logs --tail=20"
}

pilot_logs() {
    local service="${1:-}"
    if [ -n "$service" ]; then
        pilot_cmd "cd /opt/dive-v3 && sudo docker compose -f docker-compose.pilot.yml logs -f $service"
    else
        pilot_cmd "cd /opt/dive-v3 && sudo docker compose -f docker-compose.pilot.yml logs -f"
    fi
}

pilot_ssh() {
    if [ "$DRY_RUN" = true ]; then
        log_dry "gcloud compute ssh $PILOT_VM --zone=$PILOT_ZONE --project=$GCP_PROJECT"
        return 0
    fi
    gcloud compute ssh "$PILOT_VM" --zone="$PILOT_ZONE" --project="$GCP_PROJECT"
}

pilot_reset() {
    log_warn "Resetting pilot VM to clean state..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "Would stop services and remove volumes on VM"
        log_dry "Would restart services with GCP secrets"
        return 0
    fi
    
    load_gcp_secrets "$INSTANCE"
    
    pilot_cmd "
cd /opt/dive-v3
echo 'Stopping services...'
sudo docker compose -f docker-compose.pilot.yml down -v 2>/dev/null || true
echo 'Removing volumes...'
sudo docker volume rm dive-v3_postgres_data dive-v3_mongo_data dive-v3_redis_data 2>/dev/null || true
"
    
    pilot_up
}

pilot_deploy() {
    log_step "Full deployment to pilot VM..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "pilot_reset"
        log_dry "Wait 90s for services"
        log_dry "terraform apply"
        log_dry "seed database"
        return 0
    fi
    
    pilot_reset
    
    log_info "Waiting for services to be healthy (90s)..."
    sleep 90
    
    log_step "Applying Terraform..."
    cmd_terraform apply pilot
    
    log_step "Seeding database..."
    pilot_cmd "cd /opt/dive-v3 && sudo docker exec dive-pilot-backend npm run seed 2>/dev/null || echo 'Seeding skipped'"
    
    log_success "Pilot deployment complete!"
}

# =============================================================================
# FEDERATION / DISTRIBUTED COMMANDS
# =============================================================================

cmd_federation() {
    local action="${1:-status}"
    shift || true
    
    case "$action" in
        status)
            echo -e "${BOLD}Federation Status:${NC}"
            echo ""
            # Check registered instances
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would query hub API for registered instances"
            else
                echo "  Registered Instances:"
                echo "    USA: https://usa-app.dive25.com"
                echo "    FRA: https://fra-app.dive25.com (pending)"
                echo "    GBR: https://gbr-app.dive25.com (pending)"
                echo "    DEU: https://deu-app.dive25.com (pending)"
            fi
            ;;
        register)
            local instance_url="${1:-}"
            if [ -z "$instance_url" ]; then
                echo "Usage: ./dive federation register <instance-url>"
                return 1
            fi
            log_step "Registering instance: $instance_url"
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would POST to hub API: /api/federation/register"
                log_dry "  instance_url: $instance_url"
                log_dry "  instance_code: $INSTANCE"
            else
                echo "Registration would connect to hub API..."
                echo "TODO: Implement hub registration endpoint"
            fi
            ;;
        sync-policies)
            log_step "Syncing policies from hub..."
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would pull policy bundle from OPAL server"
                log_dry "Would update local OPA with new policies"
            else
                # Trigger OPAL sync
                curl -X POST http://localhost:7002/data/config -d '{"entries": ["/"]}' 2>/dev/null || {
                    log_warn "OPAL client not running locally"
                    echo "Manual sync: policies are in policies/ directory"
                }
            fi
            ;;
        sync-idps)
            log_step "Syncing IdP metadata from hub..."
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would fetch IdP metadata from hub registry"
                log_dry "Would update local Keycloak IdP configurations"
            else
                echo "IdP sync would connect to hub metadata registry..."
                echo "TODO: Implement IdP metadata sync"
            fi
            ;;
        push-audit)
            log_step "Pushing audit logs to hub..."
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would export local audit logs"
                log_dry "Would POST to hub audit aggregator"
            else
                echo "Audit push would export logs to hub..."
                echo "TODO: Implement audit log aggregation"
            fi
            ;;
        *)
            echo "Federation commands:"
            echo "  status        Show federation status"
            echo "  register      Register instance with hub"
            echo "  sync-policies Pull latest policies from hub"
            echo "  sync-idps     Sync IdP metadata from hub"
            echo "  push-audit    Push audit logs to hub"
            ;;
    esac
}

cmd_hub() {
    local action="${1:-help}"
    shift || true
    
    case "$action" in
        start)
            log_step "Starting DIVE Hub services..."
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would start: opal-server, metadata-registry, federation-api"
            else
                echo "Hub services would start here..."
                echo "TODO: Create docker-compose.hub.yml"
            fi
            ;;
        status)
            echo -e "${BOLD}DIVE Hub Status:${NC}"
            echo ""
            echo "  OPAL Server:       $(curl -s -o /dev/null -w '%{http_code}' http://localhost:7002/healthz 2>/dev/null || echo 'offline')"
            echo "  Metadata Registry: $(curl -s -o /dev/null -w '%{http_code}' http://localhost:8080/health 2>/dev/null || echo 'offline')"
            echo "  Federation API:    $(curl -s -o /dev/null -w '%{http_code}' http://localhost:4000/health 2>/dev/null || echo 'offline')"
            ;;
        instances)
            echo -e "${BOLD}Registered Instances:${NC}"
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would query hub database for instances"
            else
                echo "  Would list all registered federation instances..."
            fi
            ;;
        push-policy)
            log_step "Pushing policy update to all instances..."
            if [ "$DRY_RUN" = true ]; then
                log_dry "Would trigger OPAL server to push updates"
                log_dry "All connected OPAL clients would receive new policies"
            else
                curl -X POST http://localhost:7002/policy-update 2>/dev/null || {
                    log_warn "OPAL server not running"
                }
            fi
            ;;
        *)
            echo "Hub commands (run from central hub):"
            echo "  start         Start hub services"
            echo "  status        Show hub service status"
            echo "  instances     List registered instances"
            echo "  push-policy   Push policy update to all instances"
            ;;
    esac
}

# =============================================================================
# SPOKE COMMANDS (For distributed instances)
# =============================================================================

cmd_spoke() {
    local action="${1:-help}"
    shift || true
    
    case "$action" in
        init)
            spoke_init "$@"
            ;;
        register)
            spoke_register "$@"
            ;;
        status)
            spoke_status
            ;;
        sync)
            spoke_sync
            ;;
        heartbeat)
            spoke_heartbeat
            ;;
        *)
            echo -e "${BOLD}Spoke Commands (for distributed instances):${NC}"
            echo ""
            echo "  init <code> <name>   Initialize a new spoke instance"
            echo "  register             Register this spoke with the hub"
            echo "  status               Show spoke federation status"
            echo "  sync                 Force policy sync from hub"
            echo "  heartbeat            Send heartbeat to hub"
            echo ""
            echo "Examples:"
            echo "  ./dive spoke init NZL 'New Zealand Defence'"
            echo "  ./dive spoke register"
            echo "  ./dive spoke sync"
            ;;
    esac
}

spoke_init() {
    local instance_code="${1:-}"
    local instance_name="${2:-}"
    
    if [ -z "$instance_code" ] || [ -z "$instance_name" ]; then
        log_error "Usage: ./dive spoke init <CODE> <NAME>"
        echo ""
        echo "Example: ./dive spoke init NZL 'New Zealand Defence Force'"
        return 1
    fi
    
    # Validate code is 3 letters
    if [ ${#instance_code} -ne 3 ]; then
        log_error "Instance code must be exactly 3 characters (ISO 3166-1 alpha-3)"
        return 1
    fi
    
    local code_upper=$(upper "$instance_code")
    
    echo -e "${BOLD}Initializing DIVE V3 Spoke Instance:${NC} $code_upper"
    echo ""
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "Would create spoke configuration for: $code_upper"
        log_dry "  Name: $instance_name"
        log_dry "  Code: $code_upper"
        log_dry ""
        log_dry "Would create:"
        log_dry "  - instances/$code_upper/docker-compose.yml"
        log_dry "  - instances/$code_upper/config.json"
        log_dry "  - instances/$code_upper/.env"
        return 0
    fi
    
    local spoke_dir="instances/${code_upper,,}"
    
    # Create directory structure
    log_step "Creating instance directory: $spoke_dir"
    mkdir -p "$spoke_dir"
    
    # Generate unique IDs
    local spoke_id="spoke-${code_upper,,}-$(openssl rand -hex 4)"
    local client_secret=$(openssl rand -base64 32 | tr -d '/+=')
    
    # Create config.json
    log_step "Creating spoke configuration"
    cat > "$spoke_dir/config.json" << EOF
{
  "spokeId": "$spoke_id",
  "instanceCode": "$code_upper",
  "name": "$instance_name",
  "description": "DIVE V3 Spoke Instance for $instance_name",
  "baseUrl": "https://${code_upper,,}-app.dive25.com",
  "apiUrl": "https://${code_upper,,}-api.dive25.com",
  "idpUrl": "https://${code_upper,,}-idp.dive25.com",
  "hubUrl": "https://hub.dive25.com",
  "status": "unregistered",
  "requestedScopes": [
    "policy:base",
    "data:federation_matrix",
    "data:trusted_issuers"
  ],
  "createdAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
}
EOF
    
    # Create docker-compose.yml from template
    log_step "Creating Docker Compose configuration"
    cat > "$spoke_dir/docker-compose.yml" << EOF
# DIVE V3 Spoke Instance: $code_upper ($instance_name)
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: \${POSTGRES_PASSWORD}
      POSTGRES_DB: keycloak
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U keycloak"]
      interval: 10s
      timeout: 5s
      retries: 5

  keycloak:
    image: quay.io/keycloak/keycloak:26.0.4
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: \${POSTGRES_PASSWORD}
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: \${KEYCLOAK_ADMIN_PASSWORD}
      KC_HOSTNAME: ${code_upper,,}-idp.dive25.com
      KC_HOSTNAME_STRICT: "false"
      KC_HTTP_ENABLED: "true"
    command: start --optimized
    ports:
      - "8443:8443"
    depends_on:
      postgres:
        condition: service_healthy

  mongo:
    image: mongo:7-jammy
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: \${MONGO_PASSWORD}
    volumes:
      - mongo_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5

  opa:
    image: openpolicyagent/opa:0.68.0
    command: run --server --addr :8181
    ports:
      - "8181:8181"
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8181/health"]
      interval: 10s
      timeout: 5s
      retries: 5

  opal-client:
    image: permitio/opal-client:latest
    environment:
      OPAL_SERVER_URL: \${HUB_OPAL_URL:-https://hub.dive25.com:7002}
      OPAL_CLIENT_TOKEN: \${SPOKE_OPAL_TOKEN}
      OPAL_INLINE_OPA_ENABLED: "false"
      OPAL_OPA_URL: http://opa:8181
      OPAL_SUBSCRIPTION_ID: $spoke_id
    depends_on:
      - opa

  backend:
    image: us-central1-docker.pkg.dev/dive25/dive-v3/backend:latest
    environment:
      PORT: "4000"
      INSTANCE_CODE: "$code_upper"
      KEYCLOAK_URL: http://keycloak:8080
      KEYCLOAK_REALM: dive-v3-broker
      OPA_URL: http://opa:8181
      MONGODB_URL: mongodb://admin:\${MONGO_PASSWORD}@mongo:27017/dive-v3?authSource=admin
      HUB_URL: \${HUB_URL:-https://hub.dive25.com}
      SPOKE_ID: "$spoke_id"
    ports:
      - "4000:4000"
    depends_on:
      - keycloak
      - mongo
      - opa

  frontend:
    image: us-central1-docker.pkg.dev/dive25/dive-v3/frontend:latest
    environment:
      NEXT_PUBLIC_BACKEND_URL: https://${code_upper,,}-api.dive25.com
      NEXT_PUBLIC_INSTANCE: "$code_upper"
      AUTH_KEYCLOAK_ISSUER: https://${code_upper,,}-idp.dive25.com/realms/dive-v3-broker
    ports:
      - "3000:3000"
    depends_on:
      - backend

volumes:
  postgres_data:
  mongo_data:
EOF

    # Create .env template
    log_step "Creating environment template"
    cat > "$spoke_dir/.env.template" << EOF
# DIVE V3 Spoke: $code_upper
# Copy this to .env and fill in the values

# Database Passwords (use GCP Secret Manager in production)
POSTGRES_PASSWORD=
MONGO_PASSWORD=

# Keycloak Admin
KEYCLOAK_ADMIN_PASSWORD=

# Hub Connection
HUB_URL=https://hub.dive25.com
HUB_OPAL_URL=https://hub.dive25.com:7002

# Spoke Token (received after registration approval)
SPOKE_OPAL_TOKEN=
EOF

    echo ""
    log_success "Spoke instance initialized: $code_upper"
    echo ""
    echo -e "${BOLD}Next Steps:${NC}"
    echo "  1. Copy .env.template to .env and fill in passwords"
    echo "  2. Register with hub: ./dive spoke register"
    echo "  3. Wait for hub admin approval"
    echo "  4. Start services: cd $spoke_dir && docker compose up -d"
    echo ""
    echo -e "${BOLD}Files Created:${NC}"
    echo "  - $spoke_dir/config.json"
    echo "  - $spoke_dir/docker-compose.yml"
    echo "  - $spoke_dir/.env.template"
}

spoke_register() {
    local config_file="instances/$(echo $INSTANCE | tr '[:upper:]' '[:lower:]')/config.json"
    
    if [ ! -f "$config_file" ]; then
        log_error "Spoke not initialized. Run: ./dive spoke init <CODE> <NAME>"
        return 1
    fi
    
    local spoke_config=$(cat "$config_file")
    local hub_url=$(echo "$spoke_config" | grep -o '"hubUrl"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
    
    log_step "Registering spoke with hub: $hub_url"
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "Would POST to: $hub_url/api/federation/register"
        log_dry "Request body:"
        log_dry "  $(echo "$spoke_config" | head -c 200)..."
        return 0
    fi
    
    local response=$(curl -s -X POST "$hub_url/api/federation/register" \
        -H "Content-Type: application/json" \
        -d "$spoke_config" 2>&1)
    
    if echo "$response" | grep -q '"success"[[:space:]]*:[[:space:]]*true'; then
        log_success "Registration request submitted!"
        echo ""
        echo "Response: $response"
        echo ""
        echo -e "${YELLOW}⏳ Waiting for hub admin approval...${NC}"
        echo "   Once approved, you'll receive a token to add to your .env file"
    else
        log_error "Registration failed"
        echo "Response: $response"
        return 1
    fi
}

spoke_status() {
    echo -e "${BOLD}Spoke Federation Status:${NC}"
    echo ""
    
    local config_file="instances/$(echo $INSTANCE | tr '[:upper:]' '[:lower:]')/config.json"
    
    if [ ! -f "$config_file" ]; then
        echo "  Status: Not initialized"
        echo ""
        echo "  Run: ./dive spoke init <CODE> <NAME>"
        return 0
    fi
    
    local config=$(cat "$config_file")
    local spoke_id=$(echo "$config" | grep -o '"spokeId"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
    local instance_code=$(echo "$config" | grep -o '"instanceCode"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
    local status=$(echo "$config" | grep -o '"status"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
    local hub_url=$(echo "$config" | grep -o '"hubUrl"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
    
    echo "  Spoke ID:      $spoke_id"
    echo "  Instance Code: $instance_code"
    echo "  Status:        $status"
    echo "  Hub URL:       $hub_url"
    echo ""
    
    # Check OPAL client connection
    echo "  OPAL Client:"
    local opal_health=$(curl -s -o /dev/null -w '%{http_code}' http://localhost:7000/health 2>/dev/null || echo 'offline')
    echo "    Health:      $opal_health"
    
    # Check policy version
    echo ""
    echo "  Policy:"
    if [ "$DRY_RUN" = true ]; then
        log_dry "Would query OPA for policy version"
    else
        local opa_data=$(curl -s http://localhost:8181/v1/data/dive/tenant/base/metadata 2>/dev/null || echo '{}')
        echo "    $opa_data" | head -c 100
    fi
}

spoke_sync() {
    log_step "Forcing policy sync from hub..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "Would trigger OPAL client to pull latest policies"
        return 0
    fi
    
    # Trigger OPAL client to refresh
    curl -X POST http://localhost:7000/policy-refresh 2>/dev/null && {
        log_success "Policy refresh triggered"
    } || {
        log_warn "OPAL client not running or refresh endpoint not available"
    }
}

spoke_heartbeat() {
    local config_file="instances/$(echo $INSTANCE | tr '[:upper:]' '[:lower:]')/config.json"
    
    if [ ! -f "$config_file" ]; then
        log_error "Spoke not initialized"
        return 1
    fi
    
    local config=$(cat "$config_file")
    local spoke_id=$(echo "$config" | grep -o '"spokeId"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
    local hub_url=$(echo "$config" | grep -o '"hubUrl"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
    
    log_step "Sending heartbeat to hub..."
    
    if [ "$DRY_RUN" = true ]; then
        log_dry "Would POST to: $hub_url/api/federation/heartbeat"
        return 0
    fi
    
    # Get OPA health
    local opa_healthy="true"
    curl -s http://localhost:8181/health >/dev/null 2>&1 || opa_healthy="false"
    
    # Get policy version
    local policy_version=$(curl -s http://localhost:8181/v1/data/dive/tenant/base/metadata 2>/dev/null | grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4 || echo "unknown")
    
    local response=$(curl -s -X POST "$hub_url/api/federation/heartbeat" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer ${SPOKE_TOKEN:-}" \
        -d "{
            \"spokeId\": \"$spoke_id\",
            \"opaHealthy\": $opa_healthy,
            \"policyVersion\": \"$policy_version\"
        }" 2>&1)
    
    echo "Response: $response"
}

# =============================================================================
# INFO & HELP
# =============================================================================

cmd_info() {
        print_header
    
    echo -e "${BOLD}Environment:${NC}"
    echo "  DIVE_ROOT:     $DIVE_ROOT"
    echo "  ENVIRONMENT:   $ENVIRONMENT"
    echo "  INSTANCE:      $INSTANCE"
    echo "  GCP_PROJECT:   $GCP_PROJECT"
    echo "  PILOT_VM:      $PILOT_VM"
    echo "  PILOT_ZONE:    $PILOT_ZONE"
        echo ""
    
    echo -e "${BOLD}Docker:${NC}"
    if check_docker 2>/dev/null; then
        echo "  Status: Running"
        echo "  Containers: $(docker ps --filter "name=dive" -q | wc -l | tr -d ' ') DIVE containers"
    else
        echo "  Status: Not running"
    fi
    echo ""
    
    echo -e "${BOLD}Compose Files:${NC}"
    [ -f "docker-compose.yml" ] && echo "  ✓ docker-compose.yml"
    [ -f "docker-compose.pilot.yml" ] && echo "  ✓ docker-compose.pilot.yml"
    [ -f "docker-compose.dev.yml" ] && echo "  ✓ docker-compose.dev.yml"
    echo ""
    
    echo -e "${BOLD}Terraform:${NC}"
    if check_terraform 2>/dev/null; then
        echo "  Status: Installed"
        [ -d "terraform/pilot/.terraform" ] && echo "  Pilot: Initialized" || echo "  Pilot: Not initialized"
        [ -d "terraform/instances/.terraform" ] && echo "  Instances: Initialized" || echo "  Instances: Not initialized"
    else
        echo "  Status: Not installed"
    fi
}

cmd_help() {
    print_header
    echo "Usage: ./dive [options] [command] [subcommand] [args...]"
    echo ""
    echo -e "${BOLD}Global Options:${NC}"
    echo "  --env <env>         Set environment: local, gcp, pilot (default: local)"
    echo "  --instance <inst>   Set instance: usa, fra, deu, gbr (default: usa)"
    echo "  --dry-run           Show what would be done without executing"
    echo "  --verbose           Show detailed output"
    echo "  --quiet             Suppress non-essential output"
    echo ""
    echo -e "${BOLD}Core Commands:${NC}"
    echo "  up                  Start the stack"
    echo "  down                Stop the stack"
    echo "  restart [service]   Restart stack or specific service"
    echo "  logs [service]      View logs (follow mode)"
    echo "  ps                  List running containers"
    echo "  exec <svc> [cmd]    Execute command in container"
    echo "  status              Show overall status"
    echo "  health              Health check all services"
    echo ""
    echo -e "${BOLD}Deployment Commands:${NC}"
    echo "  deploy              Full deployment workflow (validate→secrets→up→tf→seed)"
    echo "  validate            Validate prerequisites and configuration"
    echo "  reset               Reset to clean state (nuke + deploy)"
    echo "  nuke                Destroy everything (containers + volumes)"
    echo ""
    echo -e "${BOLD}Database Commands:${NC}"
    echo "  seed [instance]     Seed database with test data"
    echo "  backup              Create database backup"
    echo "  restore <dir>       Restore from backup"
    echo ""
    echo -e "${BOLD}Terraform Commands:${NC}"
    echo "  tf plan             Show Terraform plan"
    echo "  tf apply            Apply Terraform configuration"
    echo "  tf destroy          Destroy Terraform resources"
    echo "  tf output           Show Terraform outputs"
    echo ""
    echo -e "${BOLD}Secrets Commands:${NC}"
    echo "  secrets list        List all DIVE secrets in GCP"
    echo "  secrets show        Show secrets for current instance"
    echo "  secrets load        Load secrets into environment"
    echo "  secrets verify      Verify secrets can be accessed"
    echo "  secrets export      Export secrets as shell commands"
    echo ""
    echo -e "${BOLD}Remote Pilot Commands:${NC}"
    echo "  pilot up            Start services on pilot VM"
    echo "  pilot down          Stop services on pilot VM"
    echo "  pilot status        Show pilot VM status"
    echo "  pilot logs [svc]    View pilot VM logs"
    echo "  pilot ssh           SSH into pilot VM"
    echo "  pilot reset         Reset pilot VM to clean state"
    echo "  pilot deploy        Full deployment to pilot VM"
    echo ""
    echo -e "${BOLD}Distributed Federation (Hub-Spoke):${NC}"
    echo "  hub start               Start hub services (central)"
    echo "  hub status              Show hub service status"
    echo "  hub push-policy         Push policy update to all spokes"
    echo "  spoke init <code>       Initialize new spoke instance"
    echo "  spoke register          Register spoke with hub"
    echo "  spoke status            Show spoke federation status"
    echo "  spoke sync              Force policy sync from hub"
    echo "  federation status       Show overall federation status"
    echo ""
    echo -e "${BOLD}Other Commands:${NC}"
    echo "  info                Show environment info"
    echo "  help                Show this help"
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo "  ./dive up                          # Start locally with defaults"
    echo "  ./dive --dry-run deploy            # Preview full deployment"
    echo "  ./dive --env gcp up                # Start with GCP secrets"
    echo "  ./dive pilot up                    # Start on pilot VM"
    echo "  ./dive pilot deploy                # Full deployment to pilot"
    echo "  ./dive secrets verify              # Verify GCP secrets access"
    echo "  ./dive exec backend bash           # Shell into backend container"
}

# =============================================================================
# ARGUMENT PARSING
# =============================================================================

# Parse global options
while [[ $# -gt 0 ]]; do
    case "$1" in
        --env)
            ENVIRONMENT="$2"
            shift 2
            ;;
        --instance)
            INSTANCE="$2"
            shift 2
            ;;
        --dry-run|-n)
            DRY_RUN=true
            shift
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --quiet|-q)
            QUIET=true
            shift
            ;;
        -h|--help)
            cmd_help
            exit 0
            ;;
        *)
            break
        ;;
esac
done

# Main command dispatch
COMMAND="${1:-help}"
shift || true

case "$COMMAND" in
    # Core
    up)         cmd_up "$@" ;;
    down)       cmd_down "$@" ;;
    restart)    cmd_restart "$@" ;;
    logs)       cmd_logs "$@" ;;
    ps)         cmd_ps "$@" ;;
    exec)       cmd_exec "$@" ;;
    status)     cmd_status "$@" ;;
    health)     cmd_health "$@" ;;
    
    # Deployment
    deploy)     cmd_deploy "$@" ;;
    validate)   cmd_validate "$@" ;;
    reset)      cmd_reset "$@" ;;
    clean)      cmd_reset "$@" ;;
    nuke)       cmd_nuke "$@" ;;
    
    # Database
    seed)       cmd_seed "$@" ;;
    backup)     cmd_backup "$@" ;;
    restore)    cmd_restore "$@" ;;
    
    # Terraform
    tf)         cmd_terraform "$@" ;;
    terraform)  cmd_terraform "$@" ;;
    
    # Secrets
    secrets)    cmd_secrets "$@" ;;
    
    # Federation
    federation|fed) cmd_federation "$@" ;;
    hub)            cmd_hub "$@" ;;
    spoke)          cmd_spoke "$@" ;;
    
    # Info
    info)       cmd_info "$@" ;;
    
    # Pilot VM
    pilot)
        PILOT_CMD="${1:-help}"
        shift || true
        case "$PILOT_CMD" in
            up)      pilot_up ;;
            down)    pilot_down ;;
            status)  pilot_status ;;
            logs)    pilot_logs "$@" ;;
            ssh)     pilot_ssh ;;
            reset)   pilot_reset ;;
            deploy)  pilot_deploy ;;
            *)
                echo "Pilot commands: up, down, status, logs, ssh, reset, deploy"
                ;;
        esac
        ;;
    
    help|--help|-h)
        cmd_help
        ;;
    *)
        log_error "Unknown command: $COMMAND"
        cmd_help
        exit 1
        ;;
esac
